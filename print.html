<!DOCTYPE HTML>
<html lang="kr" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>catchup-onlisp</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="catchup-onlisp">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Index.html">들어가면서</a></li><li class="chapter-item expanded affix "><li class="part-title">On Lisp</li><li class="chapter-item expanded "><a href="onlisp/01-extensible-language.html">01. 확장 가능한 언어</a></li><li class="chapter-item expanded "><a href="onlisp/02-functions.html">02. 함수</a></li><li class="chapter-item expanded "><a href="onlisp/03-functional-programming.html">03. 함수형 프로그래밍</a></li><li class="chapter-item expanded "><a href="onlisp/04-utility-functions.html">04. 유틸리티 함수</a></li><li class="chapter-item expanded "><a href="onlisp/05-returning-functions.html">05. Returning Functions</a></li><li class="chapter-item expanded "><a href="onlisp/06-functions-as-representation.html">06. Functions as Representation</a></li><li class="chapter-item expanded "><a href="onlisp/07-macros.html">07. Macros</a></li><li class="chapter-item expanded "><a href="onlisp/08-when-to-use-macros.html">08. When to Use Macros</a></li><li class="chapter-item expanded "><a href="onlisp/09-variable-capture.html">09. Variable Capture</a></li><li class="chapter-item expanded "><a href="onlisp/10-other-macro-pitfalls.html">10. Other Macro Pitfalls</a></li><li class="chapter-item expanded "><a href="onlisp/11-classic-macros.html">11. Classic Macros</a></li><li class="chapter-item expanded "><a href="onlisp/12-generalized-variables.html">12. Generalized Variables</a></li><li class="chapter-item expanded "><a href="onlisp/13-computation-at-compile-time.html">13. Computation at Compile-Time</a></li><li class="chapter-item expanded "><a href="onlisp/14-anaphoric-macros.html">14. Anaphoric Macros</a></li><li class="chapter-item expanded "><a href="onlisp/15-macros-returning-functions.html">15. Macros Returning Functions</a></li><li class="chapter-item expanded "><a href="onlisp/16-macro-defining-macros.html">16. Macro-Defining Macros</a></li><li class="chapter-item expanded "><a href="onlisp/17-read-macros.html">17. Read-Macros</a></li><li class="chapter-item expanded "><a href="onlisp/18-destructuring.html">18. Destructuring</a></li><li class="chapter-item expanded "><a href="onlisp/19-a-query-compiler.html">19. A Query Compiler</a></li><li class="chapter-item expanded "><a href="onlisp/20-continuations.html">20. Continuations</a></li><li class="chapter-item expanded "><a href="onlisp/21-multiple-processes.html">21. Multiple Processes</a></li><li class="chapter-item expanded "><a href="onlisp/22-nondeterminism.html">22. Nondeterminism</a></li><li class="chapter-item expanded "><a href="onlisp/23-parsing-with-atns.html">23. Parsing with ATNs</a></li><li class="chapter-item expanded "><a href="onlisp/24-prolog.html">24. Prolog</a></li><li class="chapter-item expanded "><a href="onlisp/25-object-oriented-lisp.html">25. Object-Oriented Lisp</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">catchup-onlisp</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lispkorea/catchup-onlisp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="들어가면서"><a class="header" href="#들어가면서">들어가면서</a></h1>
<ul>
<li>
<p><a href="https://paulgraham.com/onlisp.html">paulgraham/onlisp</a></p>
</li>
<li>
<p>OnLisp 읽기</p>
<ul>
<li><a href="https://paulgraham.com/onlisptext.html">영어</a></li>
<li><a href="https://www.asahi-net.or.jp/~kc7k-nd/onlispjhtml/">일본어</a></li>
</ul>
</li>
<li>
<p>이 문서는 번역본이 아닌 코드 위주로 작성된 요약본입니다.</p>
</li>
<li>
<p>현재 작업중 WIP (Work In Progress) 인 문서입니다.</p>
</li>
</ul>
<h2 id="참고"><a class="header" href="#참고">참고</a></h2>
<ul>
<li><a href="https://github.com/lisp-korea/onlisp">https://github.com/lisp-korea/onlisp</a></li>
<li><a href="https://www.lispworks.com/documentation/HyperSpec/Front/">lispworks's hyperspec</a></li>
<li><a href="https://cl-community-spec.github.io/">cl-community-spec</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="01-확장-가능한-언어"><a class="header" href="#01-확장-가능한-언어">01. 확장 가능한 언어</a></h1>
<ul>
<li>리스프의 가장 특징적인 특성 중 하나는 작성 중인 프로그램에 맞게 조정할 수 있다는 점.</li>
<li>리스프 자체가 리스프 프로그램이며, 리스프 프로그램은 리스프 데이터 구조인 리스트으로 표현할 수 있다.</li>
</ul>
<h2 id="11-진화에-의한-디자인"><a class="header" href="#11-진화에-의한-디자인">1.1. 진화에 의한 디자인</a></h2>
<ul>
<li>
<p>프로그램을 작성하면서 계획을 세우는 능력은 두 가지 중대한 결과를 가져온다:</p>
<ul>
<li>프로그램을 작성하는 데 걸리는 시간이 짧아진다. 
<ul>
<li>계획을 세우면서 동시에 프로그램을 작성하면 주의 집중이 잘된다.</li>
</ul>
</li>
<li>그리고 그렇게 만들어진 프로그램은 더 좋은 프로그램이 된다.
<ul>
<li>프로그램의 최종 디자인은 진화의 산물이기 때문이다.</li>
<li>최종 목표를 찾는 동안 잘못된 부분을 발견하면 그 자리에서 반드시 다시 작성한다는 원칙을 지키는 한, 최종적으로 완성된 프로그램은 미리 몇 주 동안 계획을 세웠을 때보다 훨씬 더 우아한 프로그램이 될 것이다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>리스프의 가장 큰 위험은 리스프 자체가 사용자에게 악영향을 미칠 수 있다는 것</p>
<ul>
<li>리스프를 한동안 사용하게 되면 프로그래밍 언어와 애플리케이션의 궁합에 너무 민감해져서 원래 사용하던 프로그래밍 언어로 돌아가도, 리스프만큼의 필요한 유연성을 얻지 못한다라는 생각에 갇히게 될 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="12-상향식bottom-up-프로그래밍"><a class="header" href="#12-상향식bottom-up-프로그래밍">1.2. 상향식(Bottom-Up) 프로그래밍</a></h2>
<p>패스</p>
<h2 id="13-확장-가능한-소프트웨어"><a class="header" href="#13-확장-가능한-소프트웨어">1.3. 확장 가능한 소프트웨어</a></h2>
<p>패스</p>
<h2 id="14-리스프의-확장"><a class="header" href="#14-리스프의-확장">1.4. 리스프의 확장</a></h2>
<p>리스프는 함수나 매크로를 정의하는 것만으로도 언어를 확장할 수 있다.</p>
<p>함수를 이용하여 확장하는 예제: <code>map1-n</code></p>
<pre><code class="language-lisp">(mapcar #'1+ '(1 2 3 4 5 6 7 8 9 10))
;;=&gt; (2 3 4 5 6 7 8 9 10 11)
</code></pre>
<pre><code class="language-lisp">(map1-n #'1+ 10)
;;=&gt; (2 3 4 5 6 7 8 9 10 11)

(defun map1-n (fn n)
  (mapa-b fn 1 n))

(defun mapa-b (fn a b &amp;optional (step 1))
  (do ((i a (+ i step))
       (result nil))
      ((&gt; i b) (nreverse result))
    (push (funcall fn i) result)))
</code></pre>
<p>매크로를 이용하여 확장하는 예제: <code>for</code></p>
<pre><code class="language-lisp">(do ((x 1 (1+ x)))
    ((&gt; x 5))
  (print x))
;; &gt;&gt; 1
;; &gt;&gt; 2
;; &gt;&gt; 3
;; &gt;&gt; 4
;; &gt;&gt; 5
;;=&gt; NIL
</code></pre>
<pre><code class="language-lisp">(for (x 1 5)
  (print x))
;; &gt;&gt; 1
;; &gt;&gt; 2
;; &gt;&gt; 3
;; &gt;&gt; 4
;; &gt;&gt; 5
;;=&gt; NIL

(defmacro for ((var start stop) &amp;body body)
  (let ((gstop (gensym)))
    `(do ((,var ,start (1+ ,var))
          (,gstop ,stop))
         ((&gt; ,var ,gstop))
       ,@body)))
</code></pre>
<h2 id="15-왜혹은-언제-리스프인가"><a class="header" href="#15-왜혹은-언제-리스프인가">1.5. 왜(혹은 언제) 리스프인가</a></h2>
<p>패스</p>
<h2 id="짚고-넘어가기"><a class="header" href="#짚고-넘어가기">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="02-함수"><a class="header" href="#02-함수">02 함수</a></h1>
<h2 id="21-데이터로서-함수"><a class="header" href="#21-데이터로서-함수">2.1 데이터로서 함수</a></h2>
<ul>
<li>
<p>리스프 자체가 함수 집합 </p>
<ul>
<li>새로운 오퍼레이터를 추가할 수 있음.</li>
</ul>
</li>
<li>
<p>리스프 함수는</p>
<ul>
<li>런타임에 생성하고 반환 가능</li>
<li>인수로 전달가능</li>
<li>변수가 값으로 함수를 가질 수 있다.</li>
<li>함수단위나 파일 단위로 컴파일할 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="22-함수-정의"><a class="header" href="#22-함수-정의">2.2 함수 정의</a></h2>
<ul>
<li>함수 정의 방법
<ul>
<li>defun</li>
<li>lambda</li>
</ul>
</li>
</ul>
<p><code>defun</code>으로 함수 정의하기</p>
<pre><code class="language-lisp">(defun my-double (x)
  (* x 2))

#'my-double
;;=&gt; #&lt;Interpreted-Function C66ACE&gt;

(my-double 3)
;;=&gt; 6
</code></pre>
<p><code>lambda</code>로 함수 정의하기</p>
<pre><code class="language-lisp">#'(lambda (x) (* x 2))
;;=&gt; #&lt;Interpreted-Function C674CE&gt;

((lambda (x) (* x 2)) 3)
;;=&gt; 6
</code></pre>
<p>함수/변수는 다른 이름공간을 가지고 있다.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>이름 공간 분리</th><th>ex</th></tr></thead><tbody>
<tr><td>Lisp-1</td><td>분리를 안함.</td><td>Clojure</td></tr>
<tr><td>Lisp-2</td><td>분리를 함.</td><td>Common Lisp</td></tr>
</tbody></table>
</div>
<pre><code class="language-lisp">(setq my-double 2)
;;=&gt; 2

(my-double my-double)
;;=&gt; 4

(symbol-value 'my-double)
;;=&gt; 2

(symbol-function 'my-double)
;;=&gt; #&lt;Interpreted-Function C66ACE&gt;
</code></pre>
<pre><code class="language-lisp">(setq x #'append)
;;=&gt; #&lt;Compiled-Function 46B4BE&gt;

(eq (symbol-value 'x)
    (symbol-function 'append))
;;=&gt; T

(eq #'my-double (car (list #'my-double)))
;;=&gt; T
</code></pre>
<p><code>defun</code>은 심볼을 함수 이름 공간에 추가한다.</p>
<pre><code class="language-lisp">(defun my-double (x)
  (* x 2))

(setf (symbol-function 'my-double)
      #'(lambda (x) (* x 2)))
</code></pre>
<h2 id="23-인자로서의-함수"><a class="header" href="#23-인자로서의-함수">2.3 인자로서의 함수</a></h2>
<p><code>apply</code> 사용법</p>
<pre><code class="language-lisp">(+ 1 2)
;;=&gt; 3

(apply #'+ '(1 2))
;;=&gt; 3

(apply (symbol-function '+) '(1 2))
;;=&gt; 3

(apply #'(lambda (x y) (+ x y)) '(1 2))
;;=&gt; 3
</code></pre>
<p><code>funcall</code> 사용법</p>
<pre><code class="language-lisp">(apply #'+ 1 '(2))
;;=&gt; 3

(funcall #'+ 1 2)
;;=&gt; 3
</code></pre>
<p><code>mapcar</code> 사용법</p>
<pre><code class="language-lisp">(mapcar #'(lambda (x) (+ x 10))
          '(1 2 3))
;;=&gt; (11 12 13)

(mapcar #'+
        '(1 2 3)
        '(10 100 1000))
;;=&gt; (11 102 1003)
</code></pre>
<p><code>sort</code> 사용법</p>
<pre><code class="language-lisp">(sort '(1 4 2 5 6 7 3) #'&lt;)
;;=&gt; (1 2 3 4 5 6 7)
</code></pre>
<p><code>remove-if</code> 사용법</p>
<pre><code class="language-lisp">(remove-if #'evenp '(1 2 3 4 5 6 7))
;;=&gt; (1 3 5 7)

(defun our-remove-if (fn lst)
  (if (null lst)
      nil
      (if (funcall fn (car lst))
          (our-remove-if fn (cdr lst))
          (cons (car lst) (our-remove-if fn (cdr lst))))))
</code></pre>
<h2 id="24-속성으로서의-함수"><a class="header" href="#24-속성으로서의-함수">2.4 속성으로서의 함수</a></h2>
<pre><code class="language-lisp">(defun behave (animal)
  (case animal
    (dog
     (wag-tail)
     (bark))
    (rat
     (scurry)
     (squeak))
    (cat
     (rub-legs)
     (scratch-carpet))
    (human
     (speak))))

(defun wag-tail () (print &quot;wag-tail&quot;))
(defun bark () (print &quot;bark&quot;))
(defun scurry () (print &quot;scurry&quot;))
(defun squeak () (print &quot;squeak&quot;))
(defun rub-legs () (print &quot;rub-legs&quot;))
(defun scratch-carpet () (print &quot;scratch-carpet&quot;))
(defun speak () (print &quot;speak&quot;))

(behave 'dog)
;;&gt;&gt; &quot;wag-tail&quot;
;;&gt;&gt; &quot;bark&quot;

(behave 'rat)
;;&gt;&gt; &quot;scurry&quot;
;;&gt;&gt; &quot;squeak&quot;

(behave 'cat)
;;&gt;&gt; &quot;rub-legs&quot;
;;&gt;&gt; &quot;scratch-carpet&quot;

(behave 'human)
;;&gt;&gt; speak
</code></pre>
<pre><code class="language-lisp">(defun behave2 (animal)
  (funcall (get animal 'behavior)))

(setf (get 'dog 'behavior)
      #'(lambda ()
          (wag-tail)
          (bark)))

(behave2 'dog)
;;&gt;&gt; &quot;wag-tail&quot;
;;&gt;&gt; &quot;bark&quot;

(setf (get 'all 'behavior)
      #'(lambda ()
          (bark)
          (scurry)
          (scratch-carpet)))

(behave2 'all)
;;&gt;&gt; &quot;bark&quot;
;;&gt;&gt; &quot;scurry&quot;
;;&gt;&gt; &quot;scratch-carpet&quot;

</code></pre>
<h2 id="25-범위scope"><a class="header" href="#25-범위scope">2.5 범위(Scope)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>scope-test함수에서</th><th></th><th></th></tr></thead><tbody>
<tr><td>binding</td><td>x</td><td>매개변수 x와 바인딩되어있다.</td></tr>
<tr><td>free variable</td><td>y</td><td>스코프 환경에 따라 다르게됨</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>스코프</th><th></th><th>y 의 값</th></tr></thead><tbody>
<tr><td>다이나믹(dynamic)</td><td>함수의 호출 체인을 거슬러 올라감</td><td>5</td></tr>
<tr><td>렉시컬(lexical)</td><td>함수가 정의 된 시점의 환경을 거슬러 올라감</td><td>7</td></tr>
</tbody></table>
</div>
<pre><code class="language-lisp">(let ((y 7))
  (defun scope-test (x)
    (list x y)))

;; 다이나믹 스코프
;; - y의 값: 함수 호출을 감싼 let으로 정의한 5.
(let ((y 5))
  (scope-test 3))
;;=&gt; (3 5)

;; 렉시컬 스코프 - Common Lisp 기본 설정
;; - y의 값: 앞서 defun시 감싼 let으로 정의한 7.
(let ((y 5))
  (scope-test 3))
;;=&gt; (3 7)
</code></pre>
<h2 id="26-클로져closures"><a class="header" href="#26-클로져closures">2.6 클로져(Closures)</a></h2>
<p>함수에서 binding되지 않는 변수, 즉 free 변수가 있을 때, 그 변수를 포함하는 함수를 클로져라고 한다.</p>
<pre><code class="language-lisp">(defun list+ (lst n)
  (mapcar #’(lambda (x) (+ x n))
          lst))

(list+ ’(1 2 3) 10)
;;=&gt; (11 12 13)
</code></pre>
<pre><code class="language-lisp">(let ((counter 0))
  (defun new-id () (incf counter))
  (defun reset-id () (setq counter 0)))

(defun make-adder (n)
  #’(lambda (x) (+ x n)))

(setq add2 (make-adder 2)
      add10 (make-adder 10))

(funcall add2 5)
;;=&gt; 7
(funcall add10 3)
;;=&gt; 13
</code></pre>
<pre><code class="language-lisp">(defun make-adderb (n)
  #’(lambda (x &amp;optional change)
       (if change
           (setq n x)
           (+ x n))))

(setq addx (make-adderb 1))

(funcall addx 3)
;;=&gt; 4

(funcall addx 100 t)
;;=&gt; 100

(funcall addx 3)
;;=&gt; 103
</code></pre>
<pre><code class="language-lisp">(defun make-dbms (db)
  (list
    #’(lambda (key)
        (cdr (assoc key db)))
    #’(lambda (key val)
        (push (cons key val) db)
        key)
    #’(lambda (key)
        (setf db (delete key db :key #’car))
        key)))

(setq cities (make-dbms ’((boston . us) (paris . france))))

(funcall (car cities) ’boston)
;;=&gt; US

(funcall (second cities) ’london ’england)
;;=&gt; LONDON

(funcall (car cities) ’london)
;;=&gt; ENGLAND

(defun lookup (key db)
  (funcall (car db) key))
</code></pre>
<h2 id="27-지역-함수"><a class="header" href="#27-지역-함수">2.7 지역 함수</a></h2>
<p><code>labels</code> 사용법</p>
<pre><code class="language-lisp">(labels ((inc (x) (1+ x)))
  (inc 3))
;;=&gt; 4
</code></pre>
<h2 id="28-꼬리재귀tail-recursion"><a class="header" href="#28-꼬리재귀tail-recursion">2.8 꼬리재귀(Tail-Recursion)</a></h2>
<pre><code class="language-lisp">(defun our-length (lst)
  (if (null lst)
    0
    (1+ (our-length (cdr lst)))))
</code></pre>
<pre><code class="language-lisp">(defun our-find-if (fn lst)
  (if (funcall fn (car lst))
    (car lst)
    (our-find-if fn (cdr lst))))


(defun our-length (lst)
  (labels ((rec (lst acc)
(if (null lst)
acc
(rec (cdr lst) (1+ acc)))))
(rec lst 0)))

(proclaim ’(optimize speed))

(defun triangle (n)
  (labels ((tri (c n)
  (declare (type fixnum n c))
  (if (zerop n)
  c
  (tri (the fixnum (+ n c))
  (the fixnum (- n 1))))))
  (tri 0 n)))
</code></pre>
<h2 id="29-컴파일"><a class="header" href="#29-컴파일">2.9 컴파일</a></h2>
<pre><code class="language-lisp">(defun foo (x)
  (1+ x))
;;=&gt; FOO

(compiled-function-p #’foo)
;;=&gt; NIL

(compile ’foo)
;;=&gt; FOO

(compiled-function-p #’foo)
;;=&gt; T

(compile nil ’(lambda (x) (+ x 2)))
;;=&gt; #&lt;Compiled-Function BF55BE&gt;


(progn
  (compile ’bar ’(lambda (x) (* x 3)))
  (compiled-function-p #’bar))
;;=&gt; T


(let ((y 2))
  (defun foo (x) (+ x y)))

(compile ’make-adder)
;;=&gt; MAKE-ADDER
(compiled-function-p (make-adder 2))
;;=&gt; T

(defun 50th (lst) (nth 49 lst))

(proclaim ’(inline 50th))

(defun foo (lst)
  (+ (50th lst) 1))

(defun foo (lst)
  (+ (nth 49 lst) 1))
</code></pre>
<h2 id="210-functions-from-lists"><a class="header" href="#210-functions-from-lists">2.10 Functions from Lists</a></h2>
<p>패스</p>
<h2 id="짚고-넘어가기-1"><a class="header" href="#짚고-넘어가기-1">짚고 넘어가기</a></h2>
<ul>
<li>defun</li>
<li>eq</li>
<li>lambda</li>
<li>symbol-value</li>
<li>symbol-function</li>
<li>lisp1 / lisp2</li>
<li><a href="https://www.lispworks.com/documentation/lw50/CLHS/Body/s_setq.htm">setq</a></li>
<li>mapcar</li>
<li>funcall</li>
<li>labels</li>
<li>let</li>
<li>case</li>
<li>proclaim</li>
<li>optimize</li>
<li>compiled-function-p</li>
<li>compile</li>
<li>progn</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="03-함수형-프로그래밍"><a class="header" href="#03-함수형-프로그래밍">03. 함수형 프로그래밍</a></h1>
<h2 id="31-함수형-디자인"><a class="header" href="#31-함수형-디자인">3.1. 함수형 디자인</a></h2>
<ul>
<li>함수형 프로그래밍은 사이드 이펙트 없이, 값을 반환하는 함수를 조합하여 프로그램을 작성하는 것.</li>
<li>사이드 이펙트
<ul>
<li>사이드 이펙트라 함은 객체의 변경 (ex. <code>rplaca</code> ) 및 변수의 할당의 사용(ex. <code>setq</code>) 등이 있다.</li>
<li>사이드 이펙트를 지닌 함수의 갯수가 적고 있더라도 그 영향의 범위가 좁아질 수록, 프로그램의 읽기, 테스트, 디버깅은 간단해진다.</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>사이드이펙트를 불러일으키는 함수</th></tr></thead><tbody>
<tr><td>set</td></tr>
<tr><td>setq</td></tr>
<tr><td>setf</td></tr>
<tr><td>psetf</td></tr>
<tr><td>psetq</td></tr>
<tr><td>incf</td></tr>
<tr><td>decf</td></tr>
<tr><td>push</td></tr>
<tr><td>pop</td></tr>
<tr><td>pushnew</td></tr>
<tr><td>rplaca</td></tr>
<tr><td>rplacd</td></tr>
<tr><td>rotatef</td></tr>
<tr><td>shiftf</td></tr>
<tr><td>remf</td></tr>
<tr><td>remprop</td></tr>
<tr><td>remhash</td></tr>
<tr><td>let*</td></tr>
</tbody></table>
</div>
<pre><code class="language-lisp">;;; Figure 3.1: A function to reverse lists.
;;; O(n^2)
(defun bad-reverse (lst)
  (let* ((len (length lst))
         (ilimit (truncate (/ len 2))))
    (do ((i 0 (1+ i))
         (j (1- len) (1- j)))
        ((&gt;= i ilimit))
      (rotatef (nth i lst) (nth j lst)))))

(setq lst '(abc))
;;=&gt; (ABC)

(bad-reverse lst)
;;=&gt; NIL

lst
;;=&gt; (CBA)
</code></pre>
<pre><code class="language-lisp">;;; Figure 3.2: A function to return reversed lists.
;;; O(n)
(defun good-reverse (lst)
  (labels ((rev (lst acc)
             (if (null lst)
                 acc
                 (rev (cdr lst) (cons (car lst) acc)))))
    (rev lst nil)))

&gt; (setq lst '(abc))
(ABC)
&gt; (good-reverse lst)
(CBA)
&gt; lst
(ABC)
</code></pre>
<p><code>nreverse</code>와 같이 사이드 이펙트가 필요한 경우 반환 값을 <code>setq</code> 이용해 대입한다.</p>
<pre><code class="language-lisp">&gt; (setq lst '(abc))
(ABC)

&gt; (nreverse lst)
(CBA)

&gt; lst
(A)
</code></pre>
<ul>
<li>다른 프로그래밍 언어에서 부작용을 사용하는 가장 큰 이유는 다중 값을 반환하는 함수가 필요하다는 것.
<ul>
<li>언어에서 하나의 값만 반환 할 수 있으면, 다중 값을 반환하기 위해 매개 변수를 활용하여 반환함.
<ul>
<li>ex) c#에서 out 파라미터</li>
</ul>
</li>
<li>다행히 Common Lisp에서는 <code>values</code>를 이용, 다중 값을 반환할 수 있음.</li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">(defun powers (x)
  (values x (sqrt x) (expt x 2)))
;;=&gt; POWERS

(multiple-value-bind (base root square) (powers 4)
  (list base root square))
;;=&gt; (4 2.0 16)

(* (powers 4) 2)
;;=&gt; 8
</code></pre>
<pre><code class="language-lisp">(truncate 26.21875)
;;=&gt; 26
;;=&gt; 0.21875

(= (truncate 26.21875) 26)
;;=&gt; T
</code></pre>
<h2 id="32-명령형을-뒤집어보자"><a class="header" href="#32-명령형을-뒤집어보자">3.2. 명령형을 뒤집어보자</a></h2>
<p><code>imperative-style</code>을 임시 변수를 없에면서 역순으로 뒤집어 구현해보면 <code>funcional-style</code>이 된다.</p>
<pre><code class="language-lisp">(defun imperative-style (x)
  (let (y
        sqr)
    (setq y (car x))
    (setq sqr (expt y 2))
    (list 'a sqr)))

(defun funtional-style (x)
  (list 'a (expt (car x) 2)))
</code></pre>
<h2 id="33-함수형-인터페이스"><a class="header" href="#33-함수형-인터페이스">3.3. 함수형 인터페이스</a></h2>
<p>함수는 따옴표 붙은 리스트를 반환해서는 안된다.</p>
<pre><code class="language-lisp">(defun bad-exclaim (expression)
  (append expression '(oh my)))

(bad-exclaim '(lions and tigers and bears))
;;=&gt; (LIONS AND TIGERS AND BEARS OH MY)

(nconc * '(goodness))
;;=&gt; (LIONS AND TIGERS AND BEARS OH MY GOODNESS)

(bad-exclaim '(fixnums and bignums and floats))
;;=&gt; (FIXNUMS AND BIGNUMS AND FLOATS OH MY GOODNESS)
</code></pre>
<pre><code class="language-lisp">(defun good-exclaim (expression)
  (append expression (list 'oh 'my)))

(good-exclaim '(lions and tigers and bears))
;;=&gt; (LIONS AND TIGERS AND BEARS OH MY)

(nconc * '(goodness))
;;=&gt; (LIONS AND TIGERS AND BEARS OH MY GOODNESS)

(good-exclaim '(fixnums and bignums and floats))
;;=&gt; (FIXNUMS AND BIGNUMS AND FLOATS OH MY)
</code></pre>
<h2 id="34-인터렉티브-프로그래밍"><a class="header" href="#34-인터렉티브-프로그래밍">3.4. 인터렉티브 프로그래밍</a></h2>
<ul>
<li>
<p>숙련 된 Lisp 프로그래머는 테스트하기 쉽도록 프로그램을 디자인한다.</p>
<ul>
<li>사이드 이펙트를 사용하는 부분을 몇 가지 함수로 분리하고 프로그램의 대부분은 순수한 함수형 프로그래밍 스타일로 쓴다.</li>
<li>사이드 이펙트를 사용하는 것을 피할 수 없다면, 적어도 거기에 함수형 인터페이스를 포함하려고 한다.</li>
<li>하나의 함수에는 하나의 목적만.</li>
</ul>
</li>
<li>
<p>소프트웨어 개발은 ​​코드 작성과 테스트 사이클로 구성된다</p>
<ul>
<li>리스프에서는 그 사이클이 매우 짧다.</li>
</ul>
</li>
</ul>
<h2 id="짚고-넘어가기-2"><a class="header" href="#짚고-넘어가기-2">짚고 넘어가기</a></h2>
<ul>
<li>rotatef</li>
<li>nreverse</li>
<li>values</li>
<li>multiple-value-bind</li>
<li>expt</li>
<li>nconc</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="04-유틸리티-함수"><a class="header" href="#04-유틸리티-함수">04. 유틸리티 함수</a></h1>
<ul>
<li>오퍼레이터 종류
<ul>
<li>function</li>
<li>macro</li>
<li>special form (유저가 만들 수 없다)</li>
</ul>
</li>
</ul>
<h2 id="41-유틸리티의-탄생"><a class="header" href="#41-유틸리티의-탄생">4.1. 유틸리티의 탄생</a></h2>
<ul>
<li>유틸리티: 프로그램을 쉽게 쓸 수 있게 해주는 연산자.
<ul>
<li>&quot;유틸리티&quot;라는 단어에 정확한 정의가 없음.</li>
<li>어플리케이션이라고 하기엔 작고</li>
<li>일부분이라고 하기에는 너무 범용적인 경우 &quot;유틸리티&quot;라 한다.</li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">(defun nicknames (name)
  (list 'nick (concatenate 'string &quot;foo-&quot; name)))

(nicknames &quot;park&quot;)
;;=&gt; (NICK &quot;foo-park&quot;)

(setq names '(&quot;park&quot; &quot;jane&quot; &quot;june&quot;))

(defun all-nicknames (names)
  (if (null names)
      nil
   (nconc (nicknames (car names))
          (all-nicknames (cdr names)))))
  
(mapcan #'nicknames names)
;;=&gt; (NICK &quot;foo-park&quot; NICK &quot;foo-jane&quot; NICK &quot;foo-june&quot;)

(mapcan #'reverse '((2 1 0) (5 4 3)))
;; (0 1 2 3 4 5)
</code></pre>
<pre><code class="language-lisp">(defun find-books (towns)
  (let ((town (find-if #'bookshops towns))) ;; bookshops 함수 호출
    (values town (bookshops town))))        ;; bookshops 함수 호출

(find-books1 towns)
</code></pre>
<pre><code class="language-lisp">(defun find-books2 (towns)
  (if (null towns)
      nil
      (let ((shops (bookshops (car towns)))) ;; bookshops 함수 호출
        (if shops
            (values (car towns) shops)
            (find-books2 (cdr towns))))))

(find-books2 towns)
</code></pre>
<pre><code class="language-lisp">(defun find2 (fn lst)
  (if (null lst)
      nil
      (let ((val (funcall fn (car lst)))) ;; fn 함수 호출
        (if val
            (values (car lst) val)
            (find2 fn (cdr lst))))))

(find2 #'bookshops towns)
</code></pre>
<h2 id="42-추상화에-투자하라"><a class="header" href="#42-추상화에-투자하라">4.2. 추상화에 투자하라</a></h2>
<p>프로그램을 작성하고 유지하는 데 드는 비용은 프로그램이 길어짐에 따라 증가한다.</p>
<ul>
<li>유틸리티
<ul>
<li>유틸리티는 당면한 문제뿐만 아니라 일반적인 상황에 대해 작성해야 한다.</li>
<li>서둘러 작성해서는 안 된다.</li>
<li>나중에 필요할지 확실하지 않을 때는, 일단 작성한다.</li>
<li>단, 아직은 유틸리티가 아닌 서브 루틴 신분이다.(해당 프로그램에서만 사용)</li>
<li>다른 프로그램에서 그 서브 루틴을 사용할 일이 생기면, 유틸리티로 승격시켜 널리 사용할 수 있도록 한다.</li>
</ul>
</li>
</ul>
<h2 id="43-리스트에-대한-연산"><a class="header" href="#43-리스트에-대한-연산">4.3. 리스트에 대한 연산</a></h2>
<p>리스프(Lisp)의 이름은 <code>LIS</code>t <code>P</code>rocessing에서 따왔다.</p>
<pre><code class="language-lisp">(defun longer (x y)
  (labels ((compare (x y)
             (and (consp x)
                  (or (null y)
                      (compare (cdr x) (cdr y))))))
    (if (and (listp x) (listp y))
        (compare x y)
        (&gt; (length x) (length y)))))

(longer '(1 2) '(3 4 5))
;;=&gt; T

(longer '(1 2 3) '(4 5))
;;=&gt; nil
</code></pre>
<pre><code class="language-lisp">(defun filter (fn lst)
  (let ((acc nil))
    (dolist (x lst)
      (let ((val (funcall fn x)))
        (if val (push val acc))))
    (nreverse acc)))

(filter #'evenp '(1 2 3 4 5))
;;=&gt; (T T)

(filter #'(lambda (x) (if (numberp x) (1+ x)))
        '(a 1 2 b 3 c d 4))
;;=&gt; (2 3 4 5)
</code></pre>
<pre><code class="language-lisp">(defun group (source n)
  (if (zerop n)
      (error &quot;zero length&quot;))
  (labels ((rec (source acc)
             (let ((rest (nthcdr n source)))
               (if (consp rest)
                   (rec rest (cons (subseq source 0 n) acc))
                   (nreverse (cons source acc))))))
    (if source
        (rec source nil)
        nil)))

(group '(a b c d e f g) 2)
;;=&gt; ((A B) (C D) (E F) (G))
</code></pre>
<pre><code class="language-lisp">(defun flatten (x)
  (labels ((rec (x acc)
             (cond ((null x) acc)
                   ((atom x) (cons x acc))
                   (t (rec (car x) (rec (cdr x) acc))))))
    (rec x nil)))

(flatten '(a (b c) ((d e) f)))
;;=&gt; (A B C D E F)
</code></pre>
<pre><code class="language-lisp">(defun prune (test tree)
  (labels ((rec (tree acc)
             (cond ((null tree)
                    (nreverse acc))
                   ((consp (car tree))
                    (rec (cdr tree)
                         (cons (rec (car tree) nil) acc)))
                   (t
                    (rec (cdr tree)
                         (if (funcall test (car tree))
                             acc
                             (cons (car tree) acc)))))))
    (rec tree nil)))

(prune #'evenp '(1 2 (3 (4 5) 6) 7 8 (9)))
;;=&gt; (1 (3 (5)) 7 (9))
</code></pre>
<h2 id="44-검색"><a class="header" href="#44-검색">4.4. 검색</a></h2>
<pre><code class="language-lisp">
(defun before (x y lst &amp;key (test #'eql))
  (and lst
       (let ((first (car lst)))
         (cond ((funcall test y first)
                nil)
               ((funcall test x first)
                lst)
               (t
                (before x y (cdr lst) :test test))))))

(before 'a 'b '(a))
;;=&gt; (A)
</code></pre>
<pre><code class="language-lisp">(defun after (x y lst &amp;key (test #'eql))
  (let ((rest (before y x lst :test test)))
    (and rest (member x rest :test test))))

(after 'a 'b '(b a d))
;;=&gt; (A D)
(after 'a 'b '(a))
;;=&gt; NIL
</code></pre>
<pre><code class="language-lisp">(defun duplicate (obj lst &amp;key (test #'eql))
  (member obj
          (cdr (member obj lst :test test))
          :test test))

(duplicate 'a '(a b c a d))
;;=&gt; (A D)
</code></pre>
<pre><code class="language-lisp">(defun split-if (fn lst)
  (let ((acc nil))
    (do ((src lst (cdr src)))
        ((or (null src) (funcall fn (car src)))
         (values (nreverse acc) src))
      (push (car src) acc))))

(split-if #'(lambda (x) (&gt; x 3))
          '(1 2 3 4 5))
;;=&gt; (1 2 3)
;;=&gt; (4 5)
</code></pre>
<pre><code class="language-lisp">(defun best (fn lst)
  (if (null lst)
      nil
      (let ((wins (car lst)))
        (dolist (obj (cdr lst))
          (if (funcall fn obj wins)
              (setq wins obj)))
        wins)))

(best #'&gt; '(1 2 3 4 5))
;;=&gt; 5
</code></pre>
<pre><code class="language-lisp">(defun most (fn lst)
  (if (null lst)
      (values nil nil)
      (let* ((wins (car lst))
             (max (funcall fn wins)))
        (dolist (obj (cdr lst))
          (let ((score (funcall fn obj)))
            (when (&gt; score max)
              (setq wins obj)
              (setq max score))))
        (values wins max))))

(most #'length '((a b) (a b c) (a) (e f g)))
;;=&gt; (A B C)
;;=&gt; 3
</code></pre>
<pre><code class="language-lisp">(defun mostn (fn lst)
  (if (null lst)
      (values nil nil)
      (let ((result (list (car lst)))
            (max (funcall fn (car lst))))
        (dolist (obj (cdr lst))
          (let ((score (funcall fn obj)))
            (cond ((&gt; score max)
                   (setq max score)
                   (setq result (list obj)))
                  ((= score max)
                   (push obj result)))))
        (values (nreverse result) max))))

(mostn #'length '((a b) (a b c) (a) (e f g)))
;;=&gt; ((A B C) (E F G))
;;=&gt; 3
</code></pre>
<h2 id="45-맵핑"><a class="header" href="#45-맵핑">4.5. 맵핑</a></h2>
<pre><code class="language-lisp">(defun mapa-b (fn a b &amp;optional (step 1))
  (map-&gt; fn
         a
         #'(lambda (x) (&gt; x b))
         #'(lambda (x) (+ x step))))


(defun map0-n (fn n)
  (mapa-b fn 0 n))

(map0-n #'1+ 5)
;;=&gt; (1 2 3 4 5 6)


(defun map1-n (fn n)
  (mapa-b fn 1 n))

&quot;(mapa-b #'1+ -2 0 .5)
;;=&gt; (-1 -0.5 0.0 0.5 1.0)
&quot;

(defun mapa-b (fn a b &amp;optional (step 1))
  (do ((i a (+ i step))
       (result nil))
      ((&gt; i b) (nreverse result))
    (push (funcall fn i) result)))

(defun map-&gt; (fn start test-fn succ-fn)
  (do ((i start (funcall succ-fn i))
       (result nil))
      ((funcall test-fn i) (nreverse result))
    (push (funcall fn i) result)))

(defun mappend (fn &amp;rest lsts)
  (apply #'append (apply #'mapcar fn lsts)))

(defun mapcars (fn &amp;rest lsts)
  (let ((result nil))
    (dolist (lst lsts)
      (dolist (obj lst)
        (push (funcall fn obj) result)))
    (nreverse result)))

(defun rmapcar (fn &amp;rest args)
  (if (some #'atom args)
      (apply fn args)
      (apply #'mapcar
             #'(lambda (&amp;rest args)
                 (apply #'rmapcar fn args))
             args)))

(defun our-mapcan (fn &amp;rest lsts)
  (apply #'nconc (apply #'mapcar fn lsts)))

(rmapcar #'princ '(1 2 (3 4 (5) 6) 7 (8 9)))
;;&gt;&gt; 123456789
;;=&gt; (1 2 (3 4 (5) 6) 7 (8 9))

(rmapcar #'+ '(1 (2 (3) 4)) '(10 (20 (30) 40)))
;;=&gt; (11 (22 (33) 44))
</code></pre>
<h2 id="46-io"><a class="header" href="#46-io">4.6. I/O</a></h2>
<pre><code class="language-lisp">(defun readlist (&amp;rest args)
  (values (read-from-string
           (concatenate 'string &quot;(&quot; (apply #'read-line args) &quot;)&quot;))))
(readlist)
;;&lt;&lt; Call me &quot;Ed&quot;
;;=&gt; (CALL ME &quot;Ed&quot;)
</code></pre>
<pre><code class="language-lisp">(defun prompt (&amp;rest args)
  (apply #'format *query-io* args)
  (read *query-io*))

(prompt &quot;Enter a number between ~A and ~A.~%&gt;&gt; &quot; 1 10)
;;&gt;&gt; Enter a number between 1 and 10.
;;&lt;&lt; 3
;;=&gt; 3
</code></pre>
<pre><code class="language-lisp">(defun break-loop (fn quit &amp;rest args)
  (format *query-io* &quot;Entering break-loop.~%&quot;)
  (loop
    (let ((in (apply #'prompt args)))
      (if (funcall quit in)
          (return)
          (format *query-io* &quot;~A~%&quot; (funcall fn in))))))

(break-loop #'eval #'(lambda (x) (eq x :q)) &quot;&gt;&gt; &quot;)
;;&gt;&gt; Entering break-loop.
;;&gt;&gt; &gt;&gt;
;;&lt;&lt; (+ 2 3)
;;&gt;&gt; 5
;;&gt;&gt; &gt;&gt;
;;&lt;&lt; :q
;;=&gt; NIL
</code></pre>
<h2 id="47-심볼과-문자열"><a class="header" href="#47-심볼과-문자열">4.7. 심볼과 문자열</a></h2>
<pre><code class="language-lisp">(defun mkstr (&amp;rest args)
  (with-output-to-string (s)
    (dolist (a args)
      (princ a s))))

(mkstr pi &quot; pieces of &quot; 'pi)
;;=&gt; &quot;3.141592653589793d0 pieces of PI&quot;
</code></pre>
<pre><code class="language-lisp">(defun symb (&amp;rest args)
  (values (intern (apply #'mkstr args))))

(symb 'ar &quot;Madi&quot; #\L #\L 0)
;;=&gt; |ARMadiLL0|
</code></pre>
<pre><code class="language-lisp">(defun reread (&amp;rest args)
  (values (read-from-string (apply #'mkstr args))))

(reread 'a 'b &quot;c&quot;)
;;=&gt; ABC
</code></pre>
<pre><code class="language-lisp">(defun explode (sym)
  (map 'list #'(lambda (c)
                 (intern (make-string 1 :initial-element c)))
       (symbol-name sym)))

(explode 'bomb)
;;=&gt; (B O M B)
</code></pre>
<h2 id="48-밀도"><a class="header" href="#48-밀도">4.8. 밀도</a></h2>
<ul>
<li>
<p>상향식 프로그램을 읽으려면 정의된 새로운 유틸리티를 모두 이해해야 한다.</p>
<ul>
<li>이해하는데 걸린 시간은, 유틸리티 없는 경우에 비해 적을것이다.</li>
<li>유틸리티를 사용해서 코드가 읽는 게 어렵다고 말하는 사람들이 있다면, 그 사람들은 유틸리티를 사용하지 않으면 코드가 어떤 식이 될지 이해하지 못하는 사람들이다.</li>
</ul>
</li>
<li>
<p>의도적으로 유틸리티를 피하는 경우가 하나 있다.</p>
<ul>
<li>나머지 코드와 독립적으로 배포할 작은 프로그램을 작성해야 하는 경우.</li>
<li>소규모 프로그램에서는 유틸리티를 포함할 만큼 충분히 사용되지 않을 수 있.</li>
</ul>
</li>
</ul>
<h2 id="짚고-넘어가기-3"><a class="header" href="#짚고-넘어가기-3">짚고 넘어가기</a></h2>
<ul>
<li>find-if</li>
<li><a href="https://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm">mapcan</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="05-returning-functions"><a class="header" href="#05-returning-functions">05. Returning Functions</a></h1>
<h2 id="51-common-lisp-evolves"><a class="header" href="#51-common-lisp-evolves">5.1. Common Lisp Evolves</a></h2>
<h2 id="52-orthogonality"><a class="header" href="#52-orthogonality">5.2. Orthogonality</a></h2>
<h2 id="53-memoizing"><a class="header" href="#53-memoizing">5.3. Memoizing</a></h2>
<h2 id="54-composing-functions"><a class="header" href="#54-composing-functions">5.4. Composing Functions</a></h2>
<h2 id="55-recursion-on-cdrs"><a class="header" href="#55-recursion-on-cdrs">5.5. Recursion on Cdrs</a></h2>
<h2 id="56-recursion-on-subtrees"><a class="header" href="#56-recursion-on-subtrees">5.6. Recursion on Subtrees</a></h2>
<h2 id="57-when-to-build-functions"><a class="header" href="#57-when-to-build-functions">5.7. When to Build Functions</a></h2>
<h2 id="짚고-넘어가기-4"><a class="header" href="#짚고-넘어가기-4">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="06-functions-as-representation"><a class="header" href="#06-functions-as-representation">06. Functions as Representation</a></h1>
<h2 id="61-networks"><a class="header" href="#61-networks">6.1. Networks</a></h2>
<h2 id="62-compiling-networks"><a class="header" href="#62-compiling-networks">6.2. Compiling Networks</a></h2>
<h2 id="63-looking-forward"><a class="header" href="#63-looking-forward">6.3. Looking Forward</a></h2>
<h2 id="짚고-넘어가기-5"><a class="header" href="#짚고-넘어가기-5">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="07-macros"><a class="header" href="#07-macros">07. Macros</a></h1>
<h2 id="71-how-macros-work"><a class="header" href="#71-how-macros-work">7.1. How Macros Work</a></h2>
<h2 id="72-backquote"><a class="header" href="#72-backquote">7.2. Backquote</a></h2>
<h2 id="73-defining-simple-macros"><a class="header" href="#73-defining-simple-macros">7.3. Defining Simple Macros</a></h2>
<h2 id="74-testing-macroexpansion"><a class="header" href="#74-testing-macroexpansion">7.4. Testing Macroexpansion</a></h2>
<h2 id="75-destructuring-in-parame"><a class="header" href="#75-destructuring-in-parame">7.5. Destructuring in Parame</a></h2>
<h2 id="76-a-model-of-macros"><a class="header" href="#76-a-model-of-macros">7.6. A Model of Macros</a></h2>
<h2 id="77-macros-as-programs"><a class="header" href="#77-macros-as-programs">7.7. Macros as Programs</a></h2>
<h2 id="78-macro-style"><a class="header" href="#78-macro-style">7.8. Macro Style</a></h2>
<h2 id="79-dependence-on-macros"><a class="header" href="#79-dependence-on-macros">7.9. Dependence on Macros</a></h2>
<h2 id="710-macros-from-functions"><a class="header" href="#710-macros-from-functions">7.10. Macros from Functions</a></h2>
<h2 id="711-symbol-macros"><a class="header" href="#711-symbol-macros">7.11. Symbol Macros</a></h2>
<h2 id="짚고-넘어가기-6"><a class="header" href="#짚고-넘어가기-6">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="08-when-to-use-macros"><a class="header" href="#08-when-to-use-macros">08. When to Use Macros</a></h1>
<h2 id="81-when-nothing-else-will-do"><a class="header" href="#81-when-nothing-else-will-do">8.1. When Nothing Else Will Do</a></h2>
<h2 id="82-macro-or-function"><a class="header" href="#82-macro-or-function">8.2. Macro or Function?</a></h2>
<h2 id="83-applications-for-macros"><a class="header" href="#83-applications-for-macros">8.3. Applications for Macros</a></h2>
<h2 id="짚고-넘어가기-7"><a class="header" href="#짚고-넘어가기-7">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="09-variable-capture"><a class="header" href="#09-variable-capture">09. Variable Capture</a></h1>
<h2 id="91-macro-argument-capture"><a class="header" href="#91-macro-argument-capture">9.1. Macro Argument Capture</a></h2>
<h2 id="92-free-symbol-capture"><a class="header" href="#92-free-symbol-capture">9.2. Free Symbol Capture</a></h2>
<h2 id="93-when-capture-occurs"><a class="header" href="#93-when-capture-occurs">9.3. When Capture Occurs</a></h2>
<h2 id="94-avoiding-capture-with-better-names"><a class="header" href="#94-avoiding-capture-with-better-names">9.4. Avoiding Capture with Better Names</a></h2>
<h2 id="95-avoiding-capture-by-prior-evaluation"><a class="header" href="#95-avoiding-capture-by-prior-evaluation">9.5. Avoiding Capture by Prior Evaluation</a></h2>
<h2 id="96-avoiding-capture-with-gensyms"><a class="header" href="#96-avoiding-capture-with-gensyms">9.6. Avoiding Capture with Gensyms</a></h2>
<h2 id="97-avoiding-capture-with-packages"><a class="header" href="#97-avoiding-capture-with-packages">9.7. Avoiding Capture with Packages</a></h2>
<h2 id="98-capture-in-other-name-spaces"><a class="header" href="#98-capture-in-other-name-spaces">9.8. Capture in Other Name-Spaces</a></h2>
<h2 id="99-why-bother"><a class="header" href="#99-why-bother">9.9. Why Bother?</a></h2>
<h2 id="짚고-넘어가기-8"><a class="header" href="#짚고-넘어가기-8">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-other-macro-pitfalls"><a class="header" href="#10-other-macro-pitfalls">10. Other Macro Pitfalls</a></h1>
<h2 id="101-number-of-evaluations"><a class="header" href="#101-number-of-evaluations">10.1. Number of Evaluations</a></h2>
<h2 id="102-order-of-evaluation"><a class="header" href="#102-order-of-evaluation">10.2. Order of Evaluation</a></h2>
<h2 id="103-non-functional-expanders"><a class="header" href="#103-non-functional-expanders">10.3. Non-functional Expanders</a></h2>
<h2 id="104-recursion"><a class="header" href="#104-recursion">10.4. Recursion</a></h2>
<h2 id="짚고-넘어가기-9"><a class="header" href="#짚고-넘어가기-9">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-classic-macros"><a class="header" href="#11-classic-macros">11. Classic Macros</a></h1>
<h2 id="111-creating-context"><a class="header" href="#111-creating-context">11.1. Creating Context</a></h2>
<h2 id="112-the-with--macro"><a class="header" href="#112-the-with--macro">11.2. The with- Macro</a></h2>
<h2 id="113-conditional-evaluation"><a class="header" href="#113-conditional-evaluation">11.3. Conditional Evaluation</a></h2>
<h2 id="114-iteration"><a class="header" href="#114-iteration">11.4. Iteration</a></h2>
<h2 id="115-iteration-with-multiple-values"><a class="header" href="#115-iteration-with-multiple-values">11.5. Iteration with Multiple Values</a></h2>
<h2 id="116-need-for-macros"><a class="header" href="#116-need-for-macros">11.6. Need for Macros</a></h2>
<h2 id="짚고-넘어가기-10"><a class="header" href="#짚고-넘어가기-10">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-generalized-variables"><a class="header" href="#12-generalized-variables">12. Generalized Variables</a></h1>
<h2 id="121-the-concept"><a class="header" href="#121-the-concept">12.1. The Concept</a></h2>
<h2 id="122-the-multiple-evaluation-problem"><a class="header" href="#122-the-multiple-evaluation-problem">12.2. The Multiple Evaluation Problem</a></h2>
<h2 id="123-new-utilities"><a class="header" href="#123-new-utilities">12.3. New Utilities</a></h2>
<h2 id="124-more-complex-utilities"><a class="header" href="#124-more-complex-utilities">12.4. More Complex Utilities</a></h2>
<h2 id="125-defining-inversions"><a class="header" href="#125-defining-inversions">12.5. Defining Inversions</a></h2>
<h2 id="짚고-넘어가기-11"><a class="header" href="#짚고-넘어가기-11">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-computation-at-compile-time"><a class="header" href="#13-computation-at-compile-time">13. Computation at Compile-Time</a></h1>
<h2 id="131-new-utilities"><a class="header" href="#131-new-utilities">13.1. New Utilities</a></h2>
<h2 id="132-example-bezier-curves"><a class="header" href="#132-example-bezier-curves">13.2. Example: Bezier Curves</a></h2>
<h2 id="133-applications"><a class="header" href="#133-applications">13.3. Applications</a></h2>
<h2 id="짚고-넘어가기-12"><a class="header" href="#짚고-넘어가기-12">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-anaphoric-macros"><a class="header" href="#14-anaphoric-macros">14. Anaphoric Macros</a></h1>
<h2 id="141-anaphoric-variants"><a class="header" href="#141-anaphoric-variants">14.1. Anaphoric Variants</a></h2>
<h2 id="142-failure"><a class="header" href="#142-failure">14.2. Failure</a></h2>
<h2 id="143-referential-transparency"><a class="header" href="#143-referential-transparency">14.3. Referential Transparency</a></h2>
<h2 id="짚고-넘어가기-13"><a class="header" href="#짚고-넘어가기-13">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-macros-returning-functions"><a class="header" href="#15-macros-returning-functions">15. Macros Returning Functions</a></h1>
<h2 id="151-building-functions"><a class="header" href="#151-building-functions">15.1. Building Functions</a></h2>
<h2 id="152-recursion-on-cdrs"><a class="header" href="#152-recursion-on-cdrs">15.2. Recursion on Cdrs</a></h2>
<h2 id="153-recursion-on-subtrees"><a class="header" href="#153-recursion-on-subtrees">15.3. Recursion on Subtrees</a></h2>
<h2 id="154-lazy-evaluation"><a class="header" href="#154-lazy-evaluation">15.4. Lazy Evaluation</a></h2>
<h2 id="짚고-넘어가기-14"><a class="header" href="#짚고-넘어가기-14">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="16-macro-defining-macros"><a class="header" href="#16-macro-defining-macros">16. Macro-Defining Macros</a></h1>
<h2 id="161-abbreviations"><a class="header" href="#161-abbreviations">16.1. Abbreviations</a></h2>
<h2 id="162-properties"><a class="header" href="#162-properties">16.2. Properties</a></h2>
<h2 id="163-anaphoric-macros"><a class="header" href="#163-anaphoric-macros">16.3. Anaphoric Macros</a></h2>
<h2 id="짚고-넘어가기-15"><a class="header" href="#짚고-넘어가기-15">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="17-read-macros"><a class="header" href="#17-read-macros">17. Read-Macros</a></h1>
<h2 id="171-macro-characters"><a class="header" href="#171-macro-characters">17.1. Macro Characters</a></h2>
<h2 id="172-dispatching-macro-characters"><a class="header" href="#172-dispatching-macro-characters">17.2. Dispatching Macro Characters</a></h2>
<h2 id="173-delimiters"><a class="header" href="#173-delimiters">17.3. Delimiters</a></h2>
<h2 id="174-when-what-happens"><a class="header" href="#174-when-what-happens">17.4. When What Happens</a></h2>
<h2 id="짚고-넘어가기-16"><a class="header" href="#짚고-넘어가기-16">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="18-destructuring"><a class="header" href="#18-destructuring">18. Destructuring</a></h1>
<h2 id="181-destructuring-on-lists"><a class="header" href="#181-destructuring-on-lists">18.1. Destructuring on Lists</a></h2>
<h2 id="182-other-structures"><a class="header" href="#182-other-structures">18.2. Other Structures</a></h2>
<h2 id="183-reference"><a class="header" href="#183-reference">18.3. Reference</a></h2>
<h2 id="184-matching"><a class="header" href="#184-matching">18.4. Matching</a></h2>
<h2 id="짚고-넘어가기-17"><a class="header" href="#짚고-넘어가기-17">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19-a-query-compiler"><a class="header" href="#19-a-query-compiler">19. A Query Compiler</a></h1>
<h2 id="191-the-database"><a class="header" href="#191-the-database">19.1. The Database</a></h2>
<h2 id="192-pattern-matching-queries"><a class="header" href="#192-pattern-matching-queries">19.2. Pattern-Matching Queries</a></h2>
<h2 id="193-a-query-interpreter"><a class="header" href="#193-a-query-interpreter">19.3. A Query Interpreter</a></h2>
<h2 id="194-restrictions-on-binding"><a class="header" href="#194-restrictions-on-binding">19.4. Restrictions on Binding</a></h2>
<h2 id="195-a-query-compiler"><a class="header" href="#195-a-query-compiler">19.5. A Query Compiler</a></h2>
<h2 id="짚고-넘어가기-18"><a class="header" href="#짚고-넘어가기-18">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="20-continuations"><a class="header" href="#20-continuations">20. Continuations</a></h1>
<h2 id="201-scheme-continuations"><a class="header" href="#201-scheme-continuations">20.1. Scheme Continuations</a></h2>
<h2 id="202-continuation-passing-macros"><a class="header" href="#202-continuation-passing-macros">20.2. Continuation-Passing Macros</a></h2>
<h2 id="203-code-walkers-and-cps-conversion"><a class="header" href="#203-code-walkers-and-cps-conversion">20.3. Code-Walkers and CPS Conversion</a></h2>
<h2 id="짚고-넘어가기-19"><a class="header" href="#짚고-넘어가기-19">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-multiple-processes"><a class="header" href="#21-multiple-processes">21. Multiple Processes</a></h1>
<h2 id="211-the-process-abstraction"><a class="header" href="#211-the-process-abstraction">21.1. The Process Abstraction</a></h2>
<h2 id="212-implementation"><a class="header" href="#212-implementation">21.2. Implementation</a></h2>
<h2 id="213-the-less-than-rapid-prototype"><a class="header" href="#213-the-less-than-rapid-prototype">21.3. The Less-than-Rapid Prototype</a></h2>
<h2 id="짚고-넘어가기-20"><a class="header" href="#짚고-넘어가기-20">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-nondeterminism"><a class="header" href="#22-nondeterminism">22. Nondeterminism</a></h1>
<h2 id="221-the-concepts"><a class="header" href="#221-the-concepts">22.1. The Concepts</a></h2>
<h2 id="222-search"><a class="header" href="#222-search">22.2. Search</a></h2>
<h2 id="223-scheme-implementation"><a class="header" href="#223-scheme-implementation">22.3. Scheme Implementation</a></h2>
<h2 id="224-common-lisp-implementation"><a class="header" href="#224-common-lisp-implementation">22.4. Common Lisp Implementation</a></h2>
<h2 id="225-cuts"><a class="header" href="#225-cuts">22.5. Cuts</a></h2>
<h2 id="226-true-nondeterminism"><a class="header" href="#226-true-nondeterminism">22.6. True Nondeterminism</a></h2>
<h2 id="짚고-넘어가기-21"><a class="header" href="#짚고-넘어가기-21">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="23-parsing-with-atns"><a class="header" href="#23-parsing-with-atns">23. Parsing with ATNs</a></h1>
<h2 id="231-background"><a class="header" href="#231-background">23.1. Background</a></h2>
<h2 id="232-the-formalism"><a class="header" href="#232-the-formalism">23.2. The Formalism</a></h2>
<h2 id="233-nondeterminism"><a class="header" href="#233-nondeterminism">23.3. Nondeterminism</a></h2>
<h2 id="234-an-atn-compiler"><a class="header" href="#234-an-atn-compiler">23.4. An ATN Compiler</a></h2>
<h2 id="235-a-sample-atn"><a class="header" href="#235-a-sample-atn">23.5. A Sample ATN</a></h2>
<h2 id="짚고-넘어가기-22"><a class="header" href="#짚고-넘어가기-22">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="24-prolog"><a class="header" href="#24-prolog">24. Prolog</a></h1>
<h2 id="241-concepts"><a class="header" href="#241-concepts">24.1. Concepts</a></h2>
<h2 id="242-an-interpreter"><a class="header" href="#242-an-interpreter">24.2. An Interpreter</a></h2>
<h2 id="243-rules"><a class="header" href="#243-rules">24.3. Rules</a></h2>
<h2 id="244-the-need-for-nondeterminism"><a class="header" href="#244-the-need-for-nondeterminism">24.4. The Need for Nondeterminism</a></h2>
<h2 id="245-new-implementation"><a class="header" href="#245-new-implementation">24.5. New Implementation</a></h2>
<h2 id="246-adding-prolog-features"><a class="header" href="#246-adding-prolog-features">24.6. Adding Prolog Features</a></h2>
<h2 id="247-examples"><a class="header" href="#247-examples">24.7. Examples</a></h2>
<h2 id="248-the-senses-of-compile"><a class="header" href="#248-the-senses-of-compile">24.8. The Senses of Compile</a></h2>
<h2 id="짚고-넘어가기-23"><a class="header" href="#짚고-넘어가기-23">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="25-object-oriented-lisp"><a class="header" href="#25-object-oriented-lisp">25. Object-Oriented Lisp</a></h1>
<h2 id="251-plus-ca-change"><a class="header" href="#251-plus-ca-change">25.1. Plus c¸a Change</a></h2>
<h2 id="252-objects-in-plain-lisp"><a class="header" href="#252-objects-in-plain-lisp">25.2. Objects in Plain Lisp</a></h2>
<h2 id="253-classes-and-instances"><a class="header" href="#253-classes-and-instances">25.3. Classes and Instances</a></h2>
<h2 id="254-methods"><a class="header" href="#254-methods">25.4. Methods</a></h2>
<h2 id="255-auxiliary-methods-and-combination"><a class="header" href="#255-auxiliary-methods-and-combination">25.5. Auxiliary Methods and Combination</a></h2>
<h2 id="256-clos-and-lisp"><a class="header" href="#256-clos-and-lisp">25.6. CLOS and Lisp</a></h2>
<h2 id="257-when-to-object"><a class="header" href="#257-when-to-object">25.7. When to Object</a></h2>
<h2 id="짚고-넘어가기-24"><a class="header" href="#짚고-넘어가기-24">짚고 넘어가기</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
