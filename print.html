<!DOCTYPE HTML>
<html lang="kr" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>catchup-onlisp</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="catchup-onlisp">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">catchup-onlisp</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lispkorea/catchup-onlisp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="들어가면서"><a class="header" href="#들어가면서">들어가면서</a></h1>
<ul>
<li>
<p><a href="https://paulgraham.com/onlisp.html">paulgraham/onlisp</a></p>
</li>
<li>
<p>OnLisp 읽기</p>
<ul>
<li><a href="https://paulgraham.com/onlisptext.html">영어</a></li>
<li><a href="https://www.asahi-net.or.jp/~kc7k-nd/onlispjhtml/">일본어</a></li>
</ul>
</li>
<li>
<p>이 문서는 번역본이 아닌 코드 위주로 작성된 요약본입니다.</p>
<ul>
<li>물론, OnLisp 내용을 전체 다 읽고 이해한다면 좋을 것입니다.</li>
<li>다만, 시간 절약상 OnLisp를 빠르게 훝어보고 싶은, 기억을 상기시키고 싶은 분들을 위해 작성되었습니다.</li>
</ul>
</li>
<li>
<p>현재 작업중 WIP (Work In Progress) 인 문서입니다.</p>
</li>
</ul>
<h2 id="참고"><a class="header" href="#참고">참고</a></h2>
<ul>
<li><a href="https://github.com/lisp-korea/onlisp">https://github.com/lisp-korea/onlisp</a></li>
<li><a href="https://www.lispworks.com/documentation/HyperSpec/Front/">lispworks's hyperspec</a></li>
<li><a href="https://cl-community-spec.github.io/">cl-community-spec</a></li>
<li><a href="https://www.lurklurk.org/onlisp/onlisp.html">https://www.lurklurk.org/onlisp/onlisp.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="01-확장-가능한-언어"><a class="header" href="#01-확장-가능한-언어">01. 확장 가능한 언어</a></h1>
<ul>
<li>리스프의 가장 특징적인 특성 중 하나는 작성 중인 프로그램에 맞게 조정할 수 있다는 점.</li>
<li>리스프 자체가 리스프 프로그램이며, 리스프 프로그램은 리스프 데이터 구조인 리스트로 표현할 수 있다.</li>
</ul>
<h2 id="11-진화에-의한-디자인"><a class="header" href="#11-진화에-의한-디자인">1.1. 진화에 의한 디자인</a></h2>
<ul>
<li>
<p>프로그램을 작성하면서 계획을 세우는 능력은 두 가지 중대한 결과를 가져온다:</p>
<ul>
<li>프로그램을 작성하는 데 걸리는 시간이 짧아진다.
<ul>
<li>계획을 세우면서 동시에 프로그램을 작성하면 주의 집중이 잘된다.</li>
</ul>
</li>
<li>그리고 그렇게 만들어진 프로그램은 더 좋은 프로그램이 된다.
<ul>
<li>프로그램의 최종 디자인은 진화의 산물이기 때문이다.</li>
<li>최종 목표를 찾는 동안 잘못된 부분을 발견하면 그 자리에서 반드시 다시 작성한다는 원칙을 지키는 한, 최종적으로 완성된 프로그램은 미리 몇 주 동안 계획을 세웠을 때보다 훨씬 더 우아한 프로그램이 될 것이다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>리스프의 가장 큰 위험은 리스프 자체가 사용자에게 악영향을 미칠 수 있다는 것</p>
<ul>
<li>리스프를 한동안 사용하게 되면 프로그래밍 언어와 애플리케이션의 궁합에 너무 민감해져서 원래 사용하던 프로그래밍 언어로 돌아가도, 리스프만큼의 필요한 유연성을 얻지 못한다라는 생각에 갇히게 될 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="12-상향식bottom-up-프로그래밍"><a class="header" href="#12-상향식bottom-up-프로그래밍">1.2. 상향식(Bottom-Up) 프로그래밍</a></h2>
<p>패스</p>
<h2 id="13-확장-가능한-소프트웨어"><a class="header" href="#13-확장-가능한-소프트웨어">1.3. 확장 가능한 소프트웨어</a></h2>
<p>패스</p>
<h2 id="14-리스프의-확장"><a class="header" href="#14-리스프의-확장">1.4. 리스프의 확장</a></h2>
<p>리스프는 함수나 매크로를 정의하는 것만으로도 언어를 확장할 수 있다.</p>
<p>함수를 이용하여 확장하는 예제: <code>map1-n</code></p>
<pre><code class="language-lisp">(mapcar #'1+ '(1 2 3 4 5 6 7 8 9 10))
;;=&gt; (2 3 4 5 6 7 8 9 10 11)
</code></pre>
<pre><code class="language-lisp">(map1-n #'1+ 10)
;;=&gt; (2 3 4 5 6 7 8 9 10 11)

(defun map1-n (fn n)
  (mapa-b fn 1 n))

(defun mapa-b (fn a b &amp;optional (step 1))
  (do ((i a (+ i step))
       (result nil))
      ((&gt; i b) (nreverse result))
    (push (funcall fn i) result)))
</code></pre>
<p>매크로를 이용하여 확장하는 예제: <code>for</code></p>
<pre><code class="language-lisp">(do ((x 1 (1+ x)))
    ((&gt; x 5))
  (print x))
;; &gt;&gt; 1
;; &gt;&gt; 2
;; &gt;&gt; 3
;; &gt;&gt; 4
;; &gt;&gt; 5
;;=&gt; NIL
</code></pre>
<pre><code class="language-lisp">(for (x 1 5)
  (print x))
;; &gt;&gt; 1
;; &gt;&gt; 2
;; &gt;&gt; 3
;; &gt;&gt; 4
;; &gt;&gt; 5
;;=&gt; NIL

(defmacro for ((var start stop) &amp;body body)
  (let ((gstop (gensym)))
    `(do ((,var ,start (1+ ,var))
          (,gstop ,stop))
         ((&gt; ,var ,gstop))
       ,@body)))
</code></pre>
<h2 id="15-왜혹은-언제-리스프인가"><a class="header" href="#15-왜혹은-언제-리스프인가">1.5. 왜(혹은 언제) 리스프인가</a></h2>
<p>패스</p>
<h2 id="짚고-넘어가기"><a class="header" href="#짚고-넘어가기">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="02-함수"><a class="header" href="#02-함수">02 함수</a></h1>
<h2 id="21-데이터로서-함수"><a class="header" href="#21-데이터로서-함수">2.1 데이터로서 함수</a></h2>
<ul>
<li>
<p>리스프 자체가 함수 집합</p>
<ul>
<li>새로운 오퍼레이터를 추가할 수 있음.</li>
</ul>
</li>
<li>
<p>리스프 함수는</p>
<ul>
<li>런타임에 생성하고 반환 가능</li>
<li>인수로 전달가능</li>
<li>변수가 값으로 함수를 가질 수 있다.</li>
<li>함수단위나 파일 단위로 컴파일할 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="22-함수-정의"><a class="header" href="#22-함수-정의">2.2 함수 정의</a></h2>
<ul>
<li>함수 정의 방법
<ul>
<li>defun</li>
<li>lambda</li>
</ul>
</li>
</ul>
<p><code>defun</code>으로 함수 정의하기</p>
<pre><code class="language-lisp">(defun my-double (x)
  (* x 2))

#'my-double
;;=&gt; #&lt;Interpreted-Function C66ACE&gt;

(my-double 3)
;;=&gt; 6
</code></pre>
<p><code>lambda</code>로 함수 정의하기</p>
<pre><code class="language-lisp">#'(lambda (x) (* x 2))
;;=&gt; #&lt;Interpreted-Function C674CE&gt;

((lambda (x) (* x 2)) 3)
;;=&gt; 6
</code></pre>
<p>함수/변수는 다른 이름공간을 가지고 있다.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>이름 공간 분리</th><th>ex</th></tr></thead><tbody>
<tr><td>Lisp-1</td><td>분리를 안함.</td><td>Clojure</td></tr>
<tr><td>Lisp-2</td><td>분리를 함.</td><td>Common Lisp</td></tr>
</tbody></table>
</div>
<pre><code class="language-lisp">(setq my-double 2)
;;=&gt; 2

(my-double my-double)
;;=&gt; 4

(symbol-value 'my-double)
;;=&gt; 2

(symbol-function 'my-double)
;;=&gt; #&lt;Interpreted-Function C66ACE&gt;
</code></pre>
<pre><code class="language-lisp">(setq x #'append)
;;=&gt; #&lt;Compiled-Function 46B4BE&gt;

(eq (symbol-value 'x)
    (symbol-function 'append))
;;=&gt; T

(eq #'my-double (car (list #'my-double)))
;;=&gt; T
</code></pre>
<p><code>defun</code>은 심볼을 함수 이름 공간에 추가한다.</p>
<pre><code class="language-lisp">(defun my-double (x)
  (* x 2))

(setf (symbol-function 'my-double)
      #'(lambda (x) (* x 2)))
</code></pre>
<h2 id="23-인자로서의-함수"><a class="header" href="#23-인자로서의-함수">2.3 인자로서의 함수</a></h2>
<p><code>apply</code> 사용법</p>
<pre><code class="language-lisp">(+ 1 2)
;;=&gt; 3

(apply #'+ '(1 2))
;;=&gt; 3

(apply (symbol-function '+) '(1 2))
;;=&gt; 3

(apply #'(lambda (x y) (+ x y)) '(1 2))
;;=&gt; 3
</code></pre>
<p><code>funcall</code> 사용법</p>
<pre><code class="language-lisp">(apply #'+ 1 '(2))
;;=&gt; 3

(funcall #'+ 1 2)
;;=&gt; 3
</code></pre>
<p><code>mapcar</code> 사용법</p>
<pre><code class="language-lisp">(mapcar #'(lambda (x) (+ x 10))
          '(1 2 3))
;;=&gt; (11 12 13)

(mapcar #'+
        '(1 2 3)
        '(10 100 1000))
;;=&gt; (11 102 1003)
</code></pre>
<p><code>sort</code> 사용법</p>
<pre><code class="language-lisp">(sort '(1 4 2 5 6 7 3) #'&lt;)
;;=&gt; (1 2 3 4 5 6 7)
</code></pre>
<p><code>remove-if</code> 사용법</p>
<pre><code class="language-lisp">(remove-if #'evenp '(1 2 3 4 5 6 7))
;;=&gt; (1 3 5 7)

(defun our-remove-if (fn lst)
  (if (null lst)
      nil
      (if (funcall fn (car lst))
          (our-remove-if fn (cdr lst))
          (cons (car lst) (our-remove-if fn (cdr lst))))))
</code></pre>
<h2 id="24-속성으로서의-함수"><a class="header" href="#24-속성으로서의-함수">2.4 속성으로서의 함수</a></h2>
<pre><code class="language-lisp">(defun behave (animal)
  (case animal
    (dog
     (wag-tail)
     (bark))
    (rat
     (scurry)
     (squeak))
    (cat
     (rub-legs)
     (scratch-carpet))
    (human
     (speak))))

(defun wag-tail () (print "wag-tail"))
(defun bark () (print "bark"))
(defun scurry () (print "scurry"))
(defun squeak () (print "squeak"))
(defun rub-legs () (print "rub-legs"))
(defun scratch-carpet () (print "scratch-carpet"))
(defun speak () (print "speak"))

(behave 'dog)
;;&gt;&gt; "wag-tail"
;;&gt;&gt; "bark"

(behave 'rat)
;;&gt;&gt; "scurry"
;;&gt;&gt; "squeak"

(behave 'cat)
;;&gt;&gt; "rub-legs"
;;&gt;&gt; "scratch-carpet"

(behave 'human)
;;&gt;&gt; speak
</code></pre>
<pre><code class="language-lisp">(defun behave2 (animal)
  (funcall (get animal 'behavior)))

(setf (get 'dog 'behavior)
      #'(lambda ()
          (wag-tail)
          (bark)))

(behave2 'dog)
;;&gt;&gt; "wag-tail"
;;&gt;&gt; "bark"

(setf (get 'all 'behavior)
      #'(lambda ()
          (bark)
          (scurry)
          (scratch-carpet)))

(behave2 'all)
;;&gt;&gt; "bark"
;;&gt;&gt; "scurry"
;;&gt;&gt; "scratch-carpet"

</code></pre>
<h2 id="25-범위scope"><a class="header" href="#25-범위scope">2.5 범위(Scope)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>scope-test함수에서</th><th></th><th></th></tr></thead><tbody>
<tr><td>binding</td><td>x</td><td>매개변수 x와 바인딩되어있다.</td></tr>
<tr><td>free variable</td><td>y</td><td>스코프 환경에 따라 다르게됨</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>스코프</th><th></th><th>y 의 값</th></tr></thead><tbody>
<tr><td>다이나믹(dynamic)</td><td>함수의 호출 체인을 거슬러 올라감</td><td>5</td></tr>
<tr><td>렉시컬(lexical)</td><td>함수가 정의 된 시점의 환경을 거슬러 올라감</td><td>7</td></tr>
</tbody></table>
</div>
<pre><code class="language-lisp">(let ((y 7))
  (defun scope-test (x)
    (list x y)))

;; 다이나믹 스코프
;; - y의 값: 함수 호출을 감싼 let으로 정의한 5.
(let ((y 5))
  (scope-test 3))
;;=&gt; (3 5)

;; 렉시컬 스코프 - Common Lisp 기본 설정
;; - y의 값: 앞서 defun시 감싼 let으로 정의한 7.
(let ((y 5))
  (scope-test 3))
;;=&gt; (3 7)
</code></pre>
<h2 id="26-클로져closures"><a class="header" href="#26-클로져closures">2.6 클로져(Closures)</a></h2>
<p>함수에서 binding되지 않는 변수, 즉 free 변수가 있을 때, 그 변수를 포함하는 함수를 클로져라고 한다.</p>
<pre><code class="language-lisp">(defun list+ (lst n)
  (mapcar #’(lambda (x) (+ x n))
          lst))

(list+ ’(1 2 3) 10)
;;=&gt; (11 12 13)
</code></pre>
<pre><code class="language-lisp">(let ((counter 0))
  (defun new-id ()
    (incf counter))
  (defun reset-id ()
    (setq counter 0)))

(defun make-adder (n)
  #’(lambda (x) (+ x n)))

(setq add2 (make-adder 2)
      add10 (make-adder 10))

(funcall add2 5)
;;=&gt; 7
(funcall add10 3)
;;=&gt; 13
</code></pre>
<pre><code class="language-lisp">(defun make-adderb (n)
  #’(lambda (x &amp;optional change)
       (if change
           (setq n x)
           (+ x n))))

(setq addx (make-adderb 1))

(funcall addx 3)
;;=&gt; 4

(funcall addx 100 t)
;;=&gt; 100

(funcall addx 3)
;;=&gt; 103
</code></pre>
<pre><code class="language-lisp">(defun make-dbms (db)
  (list
    #’(lambda (key)
        (cdr (assoc key db)))
    #’(lambda (key val)
        (push (cons key val) db)
        key)
    #’(lambda (key)
        (setf db (delete key db :key #’car))
        key)))

(setq cities (make-dbms ’((boston . us) (paris . france))))

(funcall (car cities) ’boston)
;;=&gt; US

(funcall (second cities) ’london ’england)
;;=&gt; LONDON

(funcall (car cities) ’london)
;;=&gt; ENGLAND

(defun lookup (key db)
  (funcall (car db) key))
</code></pre>
<h2 id="27-지역-함수"><a class="header" href="#27-지역-함수">2.7 지역 함수</a></h2>
<p><code>labels</code> 사용법</p>
<pre><code class="language-lisp">(labels ((inc (x) (1+ x)))
  (inc 3))
;;=&gt; 4
</code></pre>
<h2 id="28-꼬리-재귀tail-recursion"><a class="header" href="#28-꼬리-재귀tail-recursion">2.8 꼬리 재귀(Tail-Recursion)</a></h2>
<p><code>our-length</code>함수의 끝이 <code>our-length</code>으로 끝나는게 아니라 <code>1+</code>가 감싸는 형태로 되어있다. 이와 같은 형태는 꼬리 재귀 형태가 될 수 없다.</p>
<pre><code class="language-lisp">(defun our-length (lst)
  (if (null lst)
      0
      (1+ (our-length (cdr lst)))))
</code></pre>
<p><code>our-find-if</code>는 <code>our-find-if</code>로 끝나는 꼬리 재귀 형태이다.</p>
<pre><code class="language-lisp">(defun our-find-if (fn lst)
  (if (funcall fn (car lst))
      (car lst)
      (our-find-if fn (cdr lst))))
</code></pre>
<p><code>our-length</code>는 <code>labels</code>를 이용하여 내부에 꼬리 재귀 형태의 <code>rec</code> 함수를 정의하였다.</p>
<pre><code class="language-lisp">(defun our-length (lst)
  (labels ((rec (lst acc)
             (if (null lst)
                 acc
                 (rec (cdr lst) (1+ acc)))))
    (rec lst 0)))
</code></pre>
<pre><code class="language-lisp">;; Common Lisp에서 꼬리 재귀 최적화를 디폴트가 아닌 경우, 다음과 같이 추가 선언이 필요하다.
(proclaim '(optimize speed))
</code></pre>
<pre><code class="language-lisp">;; 속도 향상을 위한 꼬리 재귀 + 타입 선언 예제.
;; 1 ~ n 까지의 합을 구하는 함수.

(defun triangle (n)
  (labels ((tri (c n)
             (declare (type fixnum n c))
             (if (zerop n)
                 c
                 (tri (the fixnum (+ n c))
                      (the fixnum (- n 1))))))
    (tri 0 n)))
</code></pre>
<h2 id="29-컴파일"><a class="header" href="#29-컴파일">2.9 컴파일</a></h2>
<ul>
<li><code>compile</code>함수 사용하여, 함수를 컴파일</li>
<li><code>compile-file</code>함수 사용하여, 파일을 컴파일</li>
</ul>
<pre><code class="language-lisp">(defun foo (x)
  (1+ x))
;;=&gt; FOO


;; 컴파일 됐는지 여부 확인
(compiled-function-p #’foo)
;;=&gt; NIL

(compile ’foo)
;;=&gt; FOO

(compiled-function-p #’foo)
;;=&gt; T

;; 익명함수 컴파일
(compile nil '(lambda (x) (+ x 2)))
;;=&gt; #&lt;Compiled-Function BF55BE&gt;

;; 익명함수에 이름을 붙여 컴파일
(progn
  (compile 'bar '(lambda (x) (* x 3)))
  (compiled-function-p #’bar))
;;=&gt; T


;; 렉시컬 환경에서는 컴파일이 안된다.
(let ((y 2))
  (defun foo (x)
    (+ x y)))

;; 함수를 리턴하는 함수를 컴파일하면, 리턴되는 함수도 컴파일이 되는걸 확인 할 수 있다.
(compile 'make-adder)
;;=&gt; MAKE-ADDER
(compiled-function-p (make-adder 2))
;;=&gt; T

;; 인라인 함수의 예제
(proclaim '(inline 50th))
(defun 50th (lst)
  (nth 49 lst))

(defun foo (lst)
  (+ (50th lst) 1) ;; =&gt; (+ (nth 49 lst) 1)
  )
</code></pre>
<h2 id="210-functions-from-lists"><a class="header" href="#210-functions-from-lists">2.10 Functions from Lists</a></h2>
<p>패스</p>
<h2 id="짚고-넘어가기-1"><a class="header" href="#짚고-넘어가기-1">짚고 넘어가기</a></h2>
<ul>
<li>defun</li>
<li>eq</li>
<li>lambda</li>
<li>symbol-value</li>
<li>symbol-function</li>
<li>lisp1 / lisp2</li>
<li><a href="https://www.lispworks.com/documentation/lw50/CLHS/Body/s_setq.htm">setq</a></li>
<li>mapcar</li>
<li>funcall</li>
<li>labels</li>
<li>let</li>
<li>case</li>
<li>declare
<ul>
<li>type</li>
</ul>
</li>
<li>proclaim
<ul>
<li>inline</li>
</ul>
</li>
<li>optimize</li>
<li>compiled-function-p</li>
<li>compile</li>
<li>copmile-file</li>
<li>progn</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="03-함수형-프로그래밍"><a class="header" href="#03-함수형-프로그래밍">03. 함수형 프로그래밍</a></h1>
<h2 id="31-함수형-디자인"><a class="header" href="#31-함수형-디자인">3.1. 함수형 디자인</a></h2>
<ul>
<li>함수형 프로그래밍은 사이드 이펙트 없이, 값을 반환하는 함수를 조합하여 프로그램을 작성하는 것.</li>
<li>사이드 이펙트
<ul>
<li>사이드 이펙트라 함은 객체의 변경 (ex. <code>rplaca</code> ) 및 변수의 할당의 사용(ex. <code>setq</code>) 등이 있다.</li>
<li>사이드 이펙트를 지닌 함수의 갯수가 적고 있더라도 그 영향의 범위가 좁아질 수록, 프로그램의 읽기, 테스트, 디버깅은 간단해진다.</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>사이드이펙트를 불러일으키는 함수</th></tr></thead><tbody>
<tr><td>set</td></tr>
<tr><td>setq</td></tr>
<tr><td>setf</td></tr>
<tr><td>psetf</td></tr>
<tr><td>psetq</td></tr>
<tr><td>incf</td></tr>
<tr><td>decf</td></tr>
<tr><td>push</td></tr>
<tr><td>pop</td></tr>
<tr><td>pushnew</td></tr>
<tr><td>rplaca</td></tr>
<tr><td>rplacd</td></tr>
<tr><td>rotatef</td></tr>
<tr><td>shiftf</td></tr>
<tr><td>remf</td></tr>
<tr><td>remprop</td></tr>
<tr><td>remhash</td></tr>
<tr><td>let*</td></tr>
</tbody></table>
</div>
<pre><code class="language-lisp">;;; Figure 3.1: A function to reverse lists.
;;; O(n^2)
(defun bad-reverse (lst)
  (let* ((len (length lst))
         (ilimit (truncate (/ len 2))))
    (do ((i 0 (1+ i))
         (j (1- len) (1- j)))
        ((&gt;= i ilimit))
      (rotatef (nth i lst) (nth j lst)))))

(setq lst '(abc))
;;=&gt; (ABC)
(bad-reverse lst)
;;=&gt; NIL
lst
;;=&gt; (CBA)
</code></pre>
<pre><code class="language-lisp">;;; Figure 3.2: A function to return reversed lists.
;;; O(n)
(defun good-reverse (lst)
  (labels ((rev (lst acc)
             (if (null lst)
                 acc
                 (rev (cdr lst) (cons (car lst) acc)))))
    (rev lst nil)))

&gt; (setq lst '(abc))
(ABC)
&gt; (good-reverse lst)
(CBA)
&gt; lst
(ABC)
</code></pre>
<p><code>nreverse</code>와 같이 사이드 이펙트가 필요한 경우 반환 값을 <code>setq</code> 이용해 대입한다.</p>
<pre><code class="language-lisp">&gt; (setq lst '(abc))
(ABC)

&gt; (nreverse lst)
(CBA)

&gt; lst
(A)
</code></pre>
<ul>
<li>다른 프로그래밍 언어에서 부작용을 사용하는 가장 큰 이유는 다중 값을 반환하는 함수가 필요하다는 것.
<ul>
<li>언어에서 하나의 값만 반환 할 수 있으면, 다중 값을 반환하기 위해 매개 변수를 활용하여 반환함.
<ul>
<li>ex) c#에서 out 파라미터</li>
</ul>
</li>
<li>다행히 Common Lisp에서는 <code>values</code>를 이용, 다중 값을 반환할 수 있다.</li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">(defun powers (x)
  (values x (sqrt x) (expt x 2)))
;;=&gt; POWERS

(multiple-value-bind (base root square) (powers 4)
  (list base root square))
;;=&gt; (4 2.0 16)

(* (powers 4) 2)
;;=&gt; 8
</code></pre>
<pre><code class="language-lisp">(truncate 26.21875)
;;=&gt; 26
;;=&gt; 0.21875

(= (truncate 26.21875) 26)
;;=&gt; T
</code></pre>
<h2 id="32-명령형을-뒤집어보자"><a class="header" href="#32-명령형을-뒤집어보자">3.2. 명령형을 뒤집어보자</a></h2>
<p><code>imperative-style</code>을 임시 변수를 없에면서 역순으로 뒤집어 구현해보면 <code>functional-style</code>이 된다.</p>
<pre><code class="language-lisp">(defun imperative-style (x)
  (let (y
        sqr)
    (setq y (car x))
    (setq sqr (expt y 2))
    (list 'a sqr)))

(defun functional-style (x)
  (list 'a (expt (car x) 2)))

(functional-style '(3))
;;=&gt; (A 9)
</code></pre>
<h2 id="33-함수형-인터페이스"><a class="header" href="#33-함수형-인터페이스">3.3. 함수형 인터페이스</a></h2>
<p>함수는 따옴표 붙은 리스트를 반환해서는 안된다.</p>
<pre><code class="language-lisp">(defun bad-exclaim (expression)
  (append expression '(oh my)))

(bad-exclaim '(lions and tigers and bears))
;;=&gt; (LIONS AND TIGERS AND BEARS OH MY)

(nconc * '(goodness))
;;=&gt; (LIONS AND TIGERS AND BEARS OH MY GOODNESS)

(bad-exclaim '(fixnums and bignums and floats))
;;=&gt; (FIXNUMS AND BIGNUMS AND FLOATS OH MY GOODNESS)
</code></pre>
<pre><code class="language-lisp">(defun good-exclaim (expression)
  (append expression (list 'oh 'my)))

(good-exclaim '(lions and tigers and bears))
;;=&gt; (LIONS AND TIGERS AND BEARS OH MY)

(nconc * '(goodness))
;;=&gt; (LIONS AND TIGERS AND BEARS OH MY GOODNESS)

(good-exclaim '(fixnums and bignums and floats))
;;=&gt; (FIXNUMS AND BIGNUMS AND FLOATS OH MY)
</code></pre>
<h2 id="34-인터렉티브-프로그래밍"><a class="header" href="#34-인터렉티브-프로그래밍">3.4. 인터렉티브 프로그래밍</a></h2>
<ul>
<li>
<p>숙련 된 Lisp 프로그래머는 테스트하기 쉽도록 프로그램을 디자인한다.</p>
<ul>
<li>사이드 이펙트를 사용하는 부분을 몇 가지 함수로 분리하고 프로그램의 대부분은 순수한 함수형 프로그래밍 스타일로 쓴다.</li>
<li>사이드 이펙트를 사용하는 것을 피할 수 없다면, 적어도 거기에 함수형 인터페이스를 포함하려고 한다.</li>
<li>하나의 함수에는 하나의 목적만.</li>
</ul>
</li>
<li>
<p>소프트웨어 개발은 ​​코드 작성과 테스트 사이클로 구성된다</p>
<ul>
<li>리스프에서는 그 사이클이 매우 짧다.</li>
</ul>
</li>
</ul>
<h2 id="짚고-넘어가기-2"><a class="header" href="#짚고-넘어가기-2">짚고 넘어가기</a></h2>
<ul>
<li>rotatef</li>
<li>nreverse</li>
<li>values</li>
<li>multiple-value-bind</li>
<li>expt</li>
<li><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_nconc.htm">nconc</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="04-유틸리티-함수"><a class="header" href="#04-유틸리티-함수">04. 유틸리티 함수</a></h1>
<ul>
<li>오퍼레이터 종류
<ul>
<li>함수(function)</li>
<li>매크로(macro)</li>
<li>스페셜 폼(special form)
<ul>
<li>단, 스페셜 폼은 유저가 만들 수 없다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="41-유틸리티의-탄생"><a class="header" href="#41-유틸리티의-탄생">4.1. 유틸리티의 탄생</a></h2>
<ul>
<li>유틸리티: 프로그램을 쉽게 쓸 수 있게 해주는 연산자.
<ul>
<li>"유틸리티"라는 단어에 정확한 정의가 없음.</li>
<li>어플리케이션이라고 하기엔 작고, 일부분이라고 하기에는 너무 범용적인 경우 "유틸리티"라 칭함.</li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">(defun nicknames (name)
  (list 'nick (concatenate 'string "foo-" name)))

(nicknames "park")
;;=&gt; (NICK "foo-park")

(setq names '("park" "jane" "june"))

;; all-nicknames 함수를 만들어도 되지만
(defun all-nicknames (names)
  (if (null names)
      nil
      (nconc (nicknames (car names))
             (all-nicknames (cdr names)))))
  
;; mapcan을 알고 있다면, all-nicknames 함수를 만들 필요가 없다.
(mapcan #'nicknames names)
;;=&gt; (NICK "foo-park" NICK "foo-jane" NICK "foo-june")

(mapcan #'reverse '((2 1 0) (5 4 3)))
;; (0 1 2 3 4 5)
</code></pre>
<pre><code class="language-lisp">(defun find-books (towns)
  (let ((town (find-if #'bookshops towns))) ;; bookshops 함수 호출
    (values town (bookshops town))))        ;; bookshops 함수 호출

(find-books1 towns)
</code></pre>
<pre><code class="language-lisp">(defun find-books2 (towns)
  (if (null towns)
      nil
      (let ((shops (bookshops (car towns)))) ;; bookshops 함수 호출
        (if shops
            (values (car towns) shops)
            (find-books2 (cdr towns))))))

(find-books2 towns)
</code></pre>
<pre><code class="language-lisp">(defun find2 (fn lst)
  (if (null lst)
      nil
      (let ((val (funcall fn (car lst)))) ;; fn 함수 호출
        (if val
            (values (car lst) val)
            (find2 fn (cdr lst))))))

(find2 #'bookshops towns)
</code></pre>
<h2 id="42-추상화에-투자하라"><a class="header" href="#42-추상화에-투자하라">4.2. 추상화에 투자하라</a></h2>
<p>프로그램을 작성하고 유지하는 데 드는 비용은 프로그램이 길어짐에 따라 증가한다.</p>
<ul>
<li>유틸리티
<ul>
<li>유틸리티는 당면한 문제뿐만 아니라 일반적인 상황에 대해 작성해야 한다.</li>
<li>서둘러 작성해서는 안 된다.</li>
<li>나중에 필요할지 확실하지 않을 때는, 일단 작성해 본다.</li>
<li>단, 아직은 유틸리티가 아닌 서브 루틴 신분이다.(해당 프로그램에서만 사용)</li>
<li>다른 프로그램에서 그 서브 루틴을 사용할 일이 생기면, 유틸리티로 승격시켜 널리 사용할 수 있도록 한다.</li>
</ul>
</li>
</ul>
<h2 id="43-리스트에-대한-연산"><a class="header" href="#43-리스트에-대한-연산">4.3. 리스트에 대한 연산</a></h2>
<p>리스프(Lisp)의 이름은 <code>LIS</code>t <code>P</code>rocessing에서 따왔다.</p>
<p><code>longer</code>함수의 예:</p>
<pre><code class="language-lisp">(defun longer (x y)
  (labels ((compare (x y)
             (and (consp x)
                  (or (null y)
                      (compare (cdr x) (cdr y))))))
    (if (and (listp x) (listp y))
        (compare x y)
        (&gt; (length x) (length y)))))

(longer '(1 2 3) '(4 5))
;;=&gt; T

(longer '(1 2) '(3 4 5))
;;=&gt; NIL
</code></pre>
<p><code>filter</code>함수의 예:</p>
<pre><code class="language-lisp">(defun filter (fn lst)
  (let ((acc nil))
    (dolist (x lst)
      (let ((val (funcall fn x)))
        (if val
            (push val acc))))
    (nreverse acc)))

(filter #'evenp '(1 2 3 4 5))
;;=&gt; (T T)

(filter #'(lambda (x) (if (numberp x) (1+ x)))
        '(a 1 2 b 3 c d 4))
;;=&gt; (2 3 4 5)
</code></pre>
<p><code>group</code>함수의 예:</p>
<pre><code class="language-lisp">(defun group (source n)
  (if (zerop n)
      (error "zero length"))
  (labels ((rec (source acc)
             (let ((rest (nthcdr n source)))
               (if (consp rest)
                   (rec rest (cons (subseq source 0 n) acc))
                   (nreverse (cons source acc))))))
    (if source
        (rec source nil)
        nil)))

(group '(a b c d e f g) 2)
;;=&gt; ((A B) (C D) (E F) (G))
</code></pre>
<p><code>flatten</code>함수의 예:</p>
<pre><code class="language-lisp">(defun flatten (x)
  (labels ((rec (x acc)
             (cond ((null x) acc)
                   ((atom x) (cons x acc))
                   (t (rec (car x) (rec (cdr x) acc))))))
    (rec x nil)))

(flatten '(a (b c) ((d e) f)))
;;=&gt; (A B C D E F)
</code></pre>
<p><code>prune</code>함수의 예:</p>
<pre><code class="language-lisp">(defun prune (test tree)
  (labels ((rec (tree acc)
             (cond ((null tree)
                    (nreverse acc))
                   ((consp (car tree))
                    (rec (cdr tree)
                         (cons (rec (car tree) nil) acc)))
                   (t
                    (rec (cdr tree)
                         (if (funcall test (car tree))
                             acc
                             (cons (car tree) acc)))))))
    (rec tree nil)))

(prune #'evenp '(1 2 (3 (4 5) 6) 7 8 (9)))
;;=&gt; (1 (3 (5)) 7 (9))
</code></pre>
<h2 id="44-검색"><a class="header" href="#44-검색">4.4. 검색</a></h2>
<pre><code class="language-lisp">
(defun before (x y lst &amp;key (test #'eql))
  (and lst
       (let ((first (car lst)))
         (cond ((funcall test y first)
                nil)
               ((funcall test x first)
                lst)
               (t
                (before x y (cdr lst) :test test))))))

(before 'a 'b '(a))
;;=&gt; (A)
</code></pre>
<pre><code class="language-lisp">(defun after (x y lst &amp;key (test #'eql))
  (let ((rest (before y x lst :test test)))
    (and rest (member x rest :test test))))

(after 'a 'b '(b a d))
;;=&gt; (A D)
(after 'a 'b '(a))
;;=&gt; NIL
</code></pre>
<pre><code class="language-lisp">(defun duplicate (obj lst &amp;key (test #'eql))
  (member obj
          (cdr (member obj lst :test test))
          :test test))

(duplicate 'a '(a b c a d))
;;=&gt; (A D)
</code></pre>
<pre><code class="language-lisp">(defun split-if (fn lst)
  (let ((acc nil))
    (do ((src lst (cdr src)))
        ((or (null src) (funcall fn (car src)))
         (values (nreverse acc) src))
      (push (car src) acc))))

(split-if #'(lambda (x) (&gt; x 3))
          '(1 2 3 4 5))
;;=&gt; (1 2 3)
;;=&gt; (4 5)
</code></pre>
<pre><code class="language-lisp">(defun best (fn lst)
  (if (null lst)
      nil
      (let ((wins (car lst)))
        (dolist (obj (cdr lst))
          (if (funcall fn obj wins)
              (setq wins obj)))
        wins)))

(best #'&gt; '(1 2 3 4 5))
;;=&gt; 5
</code></pre>
<pre><code class="language-lisp">(defun most (fn lst)
  (if (null lst)
      (values nil nil)
      (let* ((wins (car lst))
             (max (funcall fn wins)))
        (dolist (obj (cdr lst))
          (let ((score (funcall fn obj)))
            (when (&gt; score max)
              (setq wins obj)
              (setq max score))))
        (values wins max))))

(most #'length '((a b) (a b c) (a) (e f g)))
;;=&gt; (A B C)
;;=&gt; 3
</code></pre>
<pre><code class="language-lisp">(defun mostn (fn lst)
  (if (null lst)
      (values nil nil)
      (let ((result (list (car lst)))
            (max (funcall fn (car lst))))
        (dolist (obj (cdr lst))
          (let ((score (funcall fn obj)))
            (cond ((&gt; score max)
                   (setq max score)
                   (setq result (list obj)))
                  ((= score max)
                   (push obj result)))))
        (values (nreverse result) max))))

(mostn #'length '((a b) (a b c) (a) (e f g)))
;;=&gt; ((A B C) (E F G))
;;=&gt; 3
</code></pre>
<h2 id="45-맵핑"><a class="header" href="#45-맵핑">4.5. 맵핑</a></h2>
<pre><code class="language-lisp">(defun mapa-b (fn a b &amp;optional (step 1))
  (map-&gt; fn
         a
         #'(lambda (x) (&gt; x b))
         #'(lambda (x) (+ x step))))


(defun map0-n (fn n)
  (mapa-b fn 0 n))

(map0-n #'1+ 5)
;;=&gt; (1 2 3 4 5 6)


(defun map1-n (fn n)
  (mapa-b fn 1 n))

(mapa-b #'1+ -2 0 .5)
;;=&gt; (-1 -0.5 0.0 0.5 1.0)


(defun mapa-b (fn a b &amp;optional (step 1))
  (do ((i a (+ i step))
       (result nil))
      ((&gt; i b) (nreverse result))
    (push (funcall fn i) result)))

(defun map-&gt; (fn start test-fn succ-fn)
  (do ((i start (funcall succ-fn i))
       (result nil))
      ((funcall test-fn i) (nreverse result))
    (push (funcall fn i) result)))

(defun mappend (fn &amp;rest lsts)
  (apply #'append (apply #'mapcar fn lsts)))

(defun mapcars (fn &amp;rest lsts)
  (let ((result nil))
    (dolist (lst lsts)
      (dolist (obj lst)
        (push (funcall fn obj) result)))
    (nreverse result)))

(defun recur-mapcar (fn &amp;rest args)
  (if (some #'atom args)
      (apply fn args)
      (apply #'mapcar
             #'(lambda (&amp;rest args)
                 (apply #'recur-mapcar fn args))
             args)))

(defun our-mapcan (fn &amp;rest lsts)
  (apply #'nconc (apply #'mapcar fn lsts)))

(recur-mapcar #'princ '(1 2 (3 4 (5) 6) 7 (8 9)))
;;&gt;&gt; 123456789
;;=&gt; (1 2 (3 4 (5) 6) 7 (8 9))

(recur-mapcar #'+ '(1 (2 (3) 4)) '(10 (20 (30) 40)))
;;=&gt; (11 (22 (33) 44))
</code></pre>
<h2 id="46-io"><a class="header" href="#46-io">4.6. I/O</a></h2>
<pre><code class="language-lisp">(defun readlist (&amp;rest args)
  (values (read-from-string
           (concatenate 'string "(" (apply #'read-line args) ")"))))
(readlist)
;;&lt;&lt; Call me "Ed"
;;=&gt; (CALL ME "Ed")
</code></pre>
<pre><code class="language-lisp">(defun prompt (&amp;rest args)
  (apply #'format *query-io* args)
  (read *query-io*))

(prompt "Enter a number between ~A and ~A.~%&gt;&gt; " 1 10)
;;&gt;&gt; Enter a number between 1 and 10.
;;&lt;&lt; 3
;;=&gt; 3
</code></pre>
<pre><code class="language-lisp">(defun break-loop (fn quit &amp;rest args)
  (format *query-io* "Entering break-loop.~%")
  (loop
    (let ((in (apply #'prompt args)))
      (if (funcall quit in)
          (return)
          (format *query-io* "~A~%" (funcall fn in))))))

(break-loop #'eval #'(lambda (x) (eq x :q)) "&gt;&gt; ")
;;&gt;&gt; Entering break-loop.
;;&gt;&gt; &gt;&gt;
;;&lt;&lt; (+ 2 3)
;;&gt;&gt; 5
;;&gt;&gt; &gt;&gt;
;;&lt;&lt; :q
;;=&gt; NIL
</code></pre>
<h2 id="47-심볼과-문자열"><a class="header" href="#47-심볼과-문자열">4.7. 심볼과 문자열</a></h2>
<pre><code class="language-lisp">(defun mkstr (&amp;rest args)
  (with-output-to-string (s)
    (dolist (a args)
      (princ a s))))

(mkstr pi " pieces of " 'pi)
;;=&gt; "3.141592653589793d0 pieces of PI"
</code></pre>
<pre><code class="language-lisp">(defun symb (&amp;rest args)
  (values (intern (apply #'mkstr args))))

(symb 'ar "Madi" #\L #\L 0)
;;=&gt; |ARMadiLL0|
</code></pre>
<pre><code class="language-lisp">(defun reread (&amp;rest args)
  (values (read-from-string (apply #'mkstr args))))

(reread 'a 'b "c")
;;=&gt; ABC
</code></pre>
<pre><code class="language-lisp">(defun explode (sym)
  (map 'list #'(lambda (c)
                 (intern (make-string 1 :initial-element c)))
       (symbol-name sym)))

(explode 'bomb)
;;=&gt; (B O M B)
</code></pre>
<h2 id="48-밀도"><a class="header" href="#48-밀도">4.8. 밀도</a></h2>
<ul>
<li>
<p>상향식 프로그램을 읽으려면 정의된 새로운 유틸리티를 모두 이해해야 한다.</p>
<ul>
<li>이해하는데 걸린 시간은, 유틸리티 없는 경우에 비해 적을것이다.</li>
<li>유틸리티를 사용해서 코드가 읽는 게 어렵다고 말하는 사람들이 있다면, 그 사람들은 유틸리티를 사용하지 않으면 코드가 어떤 식이 될지 이해하지 못하는 사람들이다.</li>
</ul>
</li>
<li>
<p>의도적으로 유틸리티를 피하는 경우가 하나 있다.</p>
<ul>
<li>나머지 코드와 독립적으로 배포할 작은 프로그램을 작성해야 하는 경우.
<ul>
<li>소규모 프로그램에서는 유틸리티로 만들만큼 충분히 사용되지 않을 수 있다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="짚고-넘어가기-3"><a class="header" href="#짚고-넘어가기-3">짚고 넘어가기</a></h2>
<ul>
<li>find-if</li>
<li><a href="https://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm">mapcan</a></li>
<li>push</li>
<li>zerop</li>
<li>nreverse</li>
<li>subseq</li>
<li>nthcdr</li>
<li>dolist</li>
<li>do</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="05-함수를-반환하기"><a class="header" href="#05-함수를-반환하기">05. 함수를 반환하기</a></h1>
<p>새로운 함수를 생성하고 반환하는 함수를 정의함으로써, 함수를 인자로 받는 유틸리티의 효과를 증폭시킬 수 있다.</p>
<h2 id="51-진화하는-common-lisp"><a class="header" href="#51-진화하는-common-lisp">5.1. 진화하는 Common Lisp</a></h2>
<ul>
<li>CLTL2에서는 <code>complement</code>라는 함수가 추가되었다.
<ul>
<li>함수의 여함수(Complement Function)를 반환하는 함수.</li>
<li>초기 Common Lisp에는 <code>remove-if</code>와 <code>remove-if-not</code> 같이 쌍을 이루는 함수들이 있었다.</li>
<li>CLTL2에 와서는 결과적으로 <code>-if-not</code>함수들이 사라지게 되었다.</li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">(defun sample-complement (fn)
  #'(lambda (&amp;rest args)
      (not (apply fn args))))

(remove-if (sample-complement #'oddp) '(1 2 3 4 5 6))
;;=&gt; (1 3 5)
</code></pre>
<h2 id="52-직교성orthogonality"><a class="header" href="#52-직교성orthogonality">5.2. 직교성(Orthogonality)</a></h2>
<ul>
<li>
<p>직교성(orthogonal)을 지닌 프로그래밍 언어는 적은 수의 오퍼레이터를 다양한 방법으로 결합시킴으로써 여러가지 의미를 표현할 수 있다.</p>
</li>
<li>
<p><code>setf</code> 매크로는 리스프의 직교성을 향상시킨다.</p>
<ul>
<li><code>get-color</code>, <code>set-color</code>와 같은 함수들이 필요한게 아닌, <code>get</code>과 <code>setf</code>를 조합하여 동일한 효과를 얻는다.</li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">(setf (get 'ball 'color) 'red)

(symbol-plist 'ball)
;;=&gt; (COLOR RED)

(get 'ball 'color)
;;=&gt; RED
</code></pre>
<p>새로운 표현만들기 <code>def!</code>와 <code>!</code>:</p>
<pre><code class="language-lisp">(defvar *!equivs* (make-hash-table))

(defun ! (fn)
  (or (gethash fn *!equivs*) fn))

(defun def! (fn fn!)
  (setf (gethash fn *!equivs*) fn!))

(def! #'remove-if #'delete-if)

(delete-if #'oddp '(1 2 3 4))
;;=&gt; (2 4)

(funcall (! #'remove-if) #'oddp '(1 2 3 4))
;;=&gt; (2 4)
</code></pre>
<h2 id="53-메모이징memoizing"><a class="header" href="#53-메모이징memoizing">5.3. 메모이징(Memoizing)</a></h2>
<p>캐쉬(cache)를 만들어서, 함수의 결과를 저장해두고, 같은 인자로 호출될 때는 캐쉬에 저장된 값을 반환하는 방식.</p>
<pre><code class="language-lisp">(defun memoize (fn)
  (let ((cache (make-hash-table :test #'equal)))
    #'(lambda (&amp;rest args)
        (multiple-value-bind (val win) (gethash args cache)
          (if win
              val
              (setf (gethash args cache)
                    (apply fn args)))))))


(setq slowid (memoize #'(lambda (x) (sleep 5) x)))


(time (funcall slowid 1))
;;&gt;&gt; Elapsed Time = 5.15 seconds
;;=&gt; 1

(time (funcall slowid 1))
;;&gt;&gt; Elapsed Time = 0.00 seconds
;;=&gt; 1
</code></pre>
<h2 id="54-합성-함수composing-functions"><a class="header" href="#54-합성-함수composing-functions">5.4. 합성 함수(Composing Functions)</a></h2>
<ul>
<li>함수 <code>f</code>의 여함수(Complement Function)는 <code>~f</code>로 표시.</li>
</ul>
<pre><code class="language-lisp">(funcall (complement #'evenp) 1)
;;=&gt; T
</code></pre>
<ul>
<li>함수 <code>f</code>와 <code>g</code>가 있을때 합성함수(Composing Function) <code>f(g(x))</code>는 <code>f ○ g</code>로 표시.</li>
</ul>
<pre><code class="language-lisp">(defun compose (&amp;rest fns)
  (if fns
      (let ((fn1 (car (last fns)))
            (fns (butlast fns)))
        #'(lambda (&amp;rest args)
            (reduce #'funcall fns
                    :from-end t
                    :initial-value (apply fn1 args))))
      #'identity))

(funcall (compose #'1+ #'find-if) #'oddp '(2 3 4))
;;=&gt; 4
</code></pre>
<ul>
<li><code>fif</code>
<ul>
<li><code>f</code>unction <code>if</code></li>
<li><code>if</code> 만족시 <code>then</code> 아니면 <code>else</code> 적용</li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">(defun fif (if then &amp;optional else)
  #'(lambda (x)
      (if (funcall if x)
          (funcall then x)
          (if else (funcall else x)))))

(mapcar (fif #'oddp #'1+ #'1-)
        '(1 2 3 4 5))
;;=&gt; (2 1 4 3 6)
</code></pre>
<ul>
<li><code>fint</code>
<ul>
<li><code>f</code>unction <code>int</code>ersection</li>
<li>함수들을 모두 만족시</li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">(defun fint (fn &amp;rest fns)
  (if (null fns)
      fn
      (let ((chain (apply #'fint fns)))
        #'(lambda (x) 
            (and (funcall fn x) (funcall chain x))))))

(mapcar (fint #'oddp #'(lambda (x) (&gt; x 3)))
        '(1 2 3 4 5))
;; (NIL NIL NIL NIL T)
</code></pre>
<ul>
<li><code>fun</code>
<ul>
<li><code>f</code>unction <code>un</code>ion</li>
<li>함수들 중 하나라도 만족시</li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">(defun fun (fn &amp;rest fns)
  (if (null fns)
      fn
      (let ((chain (apply #'fun fns)))
        #'(lambda (x)
            (or (funcall fn x) (funcall chain x))))))

(mapcar (fun #'oddp #'(lambda (x) (&gt; x 3)))
        '(1 2 3 4 5))
;; (T NIL T T T)
</code></pre>
<h2 id="55-cdr을-이용한-재귀"><a class="header" href="#55-cdr을-이용한-재귀">5.5. cdr을 이용한 재귀</a></h2>
<ul>
<li><code>cdr</code>은 리스트의 두번째 요소부터 끝까지를 반환하는 함수.
<ul>
<li><code>car</code>와 <code>cdr</code>을 이용하여 전체 리스트를 순회할 수 있다.</li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">(cdr '(1 2 3 4))
;;=&gt; (2 3 4)
</code></pre>
<pre><code class="language-lisp">(defun our-length (lst)
  (if (null lst)
      0
      (1+ (our-length (cdr lst)))))

(our-length '(1 2 3))
;;=&gt; 3
</code></pre>
<pre><code class="language-lisp">(defun our-every (fn lst)
  (if (null lst)
      t
      (and (funcall fn (car lst))
           (our-every fn (cdr lst)))))

(our-every #'evenp '(2 4 6))
;;=&gt; T
</code></pre>
<ul>
<li>lrec
<ul>
<li><code>l</code>ist <code>rec</code>urser</li>
<li>리스트에 대한 재귀를 추상화한 함수</li>
<li>꼬리 재귀(tail recursion)를 사용하여 최적화한 버전이 아니지만, 간단히 구현해 본 것.</li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">(defun lrec (rec &amp;optional base)
  (labels ((self (lst)
             (if (null lst)
                 (if (functionp base)
                     (funcall base)
                     base)
                 (funcall rec (car lst)
                          #'(lambda ()
                              (self (cdr lst)))))))
    #'self))


;; 리스트 복사
(lrec #'(lambda (x f) (cons x (funcall f))))

;; 중복 삭제
(lrec #'(lambda (x f) (adjoin x (funcall f))))

;; find-if, fn을 만족시키는 x 찾기
(lrec #'(lambda (x f) (if (fn x) x (funcall f))))


; some, fn을 적용시켜 거짓이 아니면 반환
(lrec #'(lambda (x f) (or (fn x) (funcall f))))
</code></pre>
<h2 id="56-서브트리subtree와-재귀"><a class="header" href="#56-서브트리subtree와-재귀">5.6. 서브트리(subtree)와 재귀</a></h2>
<div class="table-wrapper"><table><thead><tr><th>표현식</th><th>cons cell</th></tr></thead><tbody>
<tr><td>(a . b)</td><td>(a . b)</td></tr>
<tr><td>(a b c)</td><td>(a . (b . (c . nil)))</td></tr>
<tr><td>(a b (c d))</td><td>(a . (b . ((c . (d . nil)) . nil)))</td></tr>
</tbody></table>
</div>
<p><img src="onlisp/../res/fig5_7.svg" alt="" /></p>
<p><code>our-copy-tree</code> 예제:</p>
<pre><code class="language-lisp">(defun our-copy-tree (tree)
  (if (atom tree)
      tree
      (cons (our-copy-tree (car tree))
            (if (cdr tree) (our-copy-tree (cdr tree))))))

(our-copy-tree '((a b (c d)) (e) f))
;;=&gt; ((A B (C D)) (E) F)
</code></pre>
<p><code>count-leaves</code> 예제:</p>
<pre><code class="language-lisp">(defun count-leaves (tree)
  (if (atom tree)
      1
      (+ (count-leaves (car tree))
         (or (if (cdr tree) (count-leaves (cdr tree)))
             1))))

(count-leaves '((a b (c d)) (e) f))
;;=&gt; 10
</code></pre>
<p><code>our-flatten</code> 예제:</p>
<pre><code class="language-lisp">(defun our-flatten (tree)
  (if (atom tree)
      (mklist tree)
      (nconc (flatten (car tree))
             (if (cdr tree) (our-flatten (cdr tree))))))

(our-flatten '((a b (c d)) (e) f))
;;=&gt; (A B C D E F)
</code></pre>
<p><code>rfind-if</code> 예제:</p>
<pre><code class="language-lisp">(defun rfind-if (fn tree)
  (if (atom tree)
      (and (funcall fn tree) tree)
      (or (rfind-if fn (car tree))
          (if (cdr tree) (rfind-if fn (cdr tree))))))

(rfind-if (fint #'numberp #'oddp) '(2 (3 4) 5))
;;=&gt; 3
</code></pre>
<h2 id="57-어느-시점에-함수를-만들어야-하는가"><a class="header" href="#57-어느-시점에-함수를-만들어야-하는가">5.7. 어느 시점에 함수를 만들어야 하는가</a></h2>
<ul>
<li><code>#'(lambda ... )</code>는 상수 표현식이나, 함수 호출은 <code>런타임에 평가</code>된다.</li>
<li><code>#.( ... )</code>에서의 <code>#.</code>은 리드 매크로(read macro)로 뒷따르는 <code>표현식을 읽는 시점에 평가</code>된다.</li>
</ul>
<h2 id="짚고-넘어가기-4"><a class="header" href="#짚고-넘어가기-4">짚고 넘어가기</a></h2>
<ul>
<li><a href="https://www.lispworks.com/documentation/lw51/CLHS/Body/f_get.htm">get</a></li>
<li><a href="https://www.lispworks.com/documentation/HyperSpec/Body/02_dhf.htm">#.</a> 리드 매크로</li>
<li>gethash</li>
<li>make-hash-table</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="06-표현으로서의-함수"><a class="header" href="#06-표현으로서의-함수">06. 표현으로서의 함수</a></h1>
<ul>
<li>일반적으로 데이터 구조는 무언가를 표현하는 데 사용됨.
<ul>
<li>배열은 기하학적 변환을 나타낼 수 있음.</li>
<li>트리는 명령의 계층을 표현할 수 있음.</li>
<li>그래프는 철도 네트워크를 나타낼 수 있음.</li>
</ul>
</li>
<li>리스프에서는 클로져(clozure)가 표현 수단에 사용될 수 있음.
<ul>
<li>클로저 내에서 변수 바인딩은 정보를 저장할 수 있으며 복잡한 데이터 구조를 구축 할 때 포인터의 역할을 할 수 있음.</li>
<li>바인딩을 공유하거나 서로를 참조 할 수있는 클로저 그룹을 만들어 데이터 구조와 프로그램의 장점을 결합한 하이브리드 객체를 만들 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="61-네트워크network"><a class="header" href="#61-네트워크network">6.1. 네트워크(network)</a></h2>
<p>네트워크(network): 노드(node)로 연결된 집합체</p>
<ul>
<li>클로저에는 세 가지 유용한 특성이 있다.
<ul>
<li>활성화 되어있다.(they are active)</li>
<li>로컬 상태를 가진다.(they have local state)</li>
<li>여러 인스턴스를 만들 수 있다.(we can make multiple instances of them)</li>
</ul>
</li>
</ul>
<h2 id="62-네트워크-컴파일"><a class="header" href="#62-네트워크-컴파일">6.2. 네트워크 컴파일</a></h2>
<h2 id="63-앞으로"><a class="header" href="#63-앞으로">6.3. 앞으로</a></h2>
<h2 id="짚고-넘어가기-5"><a class="header" href="#짚고-넘어가기-5">짚고 넘어가기</a></h2>
<ul>
<li>defstruct</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="07-매크로"><a class="header" href="#07-매크로">07. 매크로</a></h1>
<p><code>매크로</code>는 코드를 만드는 함수</p>
<h2 id="71-매크로가-동작하는-방식"><a class="header" href="#71-매크로가-동작하는-방식">7.1. 매크로가 동작하는 방식</a></h2>
<ol>
<li>정의한 표현식을 빌드한 다음</li>
<li>매크로 호출시 대신 해당 표현식을 평가</li>
</ol>
<pre><code class="language-lisp">(defmacro nil! (var) 
  (list 'setq var nil))

(defvar x 10)

;; 새로운 표현식을 빌딩하는 단계를 `매크로 확장(macroexpansion)` 이라고 한다.
;; 아래 매크로 호출은, 매크로 확장을 거쳐, (setq x nil)이 된다.
(nil! x)

x
;;=&gt; NIL
</code></pre>
<h2 id="72-역-따옴표backquote"><a class="header" href="#72-역-따옴표backquote">7.2. 역 따옴표(Backquote)</a></h2>
<ul>
<li>따옴표 <code>'</code> 방향을 역으로 한 역 따옴표 <code>`</code></li>
<li>백쿼트(backquote) 혹은 백틱(backtick)라고도 하는데 리스프에서는 백쿼트라는 말을 쓴다.</li>
</ul>
<pre><code class="language-lisp">(defvar a 1)
(defvar b '(2 2))
(defvar c 3)
(defvar d 4)

;; `(a b c) == '(a b c) == (list 'a 'b 'c)
;; `(a ,b c) == '(a (2 2) c)
;; `(a ,@b c) == (list 'a 2 2 'c)

`(a ,b c)
;;=&gt; (A (2 2) C)

`(a ,@b c)
;;=&gt; (A 2 2 C)
</code></pre>
<pre><code class="language-lisp">;; list를 쓴 버전
(defmacro nil! (var) 
  (list 'setq var nil))

;; 백쿼트(`)를 쓴 버전
(defmacro nil! (var) 
  `(setq ,var nil))
</code></pre>
<pre><code class="language-lisp">;; list를 쓴 버전
(defmacro nif (expr pos zero neg) 
  (list 'case 
    (list 'truncate (list 'signum expr))
    (list 1 pos)
    (list 0 zero)
    (list -1 neg)))

;; 백쿼트(`)를 쓴 버전
(defmacro nif (expr pos zero neg) 
  `(case (truncate (signum ,expr))
     (1 ,pos)
     (0 ,zero)
     (-1 ,neg)))


(mapcar #'(lambda (x) (nif x 'pos 'zero 'neg))
         '(0 2.5 -8))
;;=&gt; (ZERO POS NEG)
</code></pre>
<h2 id="73-간단한-매크로-정의"><a class="header" href="#73-간단한-매크로-정의">7.3. 간단한 매크로 정의</a></h2>
<pre><code class="language-lisp">(defmacro memq (obj lst)
  `(member ,obj ,lst :test #'eq))

(memq 'a '(1 2 3))  ; 확장 (member 'a '(1 2 3) :test #'eq)
;;=&gt; NIL

(memq 'a '(a b c))  ; 확장 (member 'a '(a b c) :test #'eq)
;;=&gt; (A B C)
</code></pre>
<h2 id="74-매크로-확장macroexpansion-확인"><a class="header" href="#74-매크로-확장macroexpansion-확인">7.4. 매크로 확장(Macroexpansion) 확인</a></h2>
<pre><code class="language-lisp">(defmacro while (test &amp;body body) 
  `(do ()
       ((not ,test))
     ,@body))

(let ((i 0))
    (while (&lt; i 3)
      (print i)
      (incf i)))
;;&gt;&gt; 1
;;&gt;&gt; 2
;;&gt;&gt; 3
;;=&gt; NIL
</code></pre>
<p><code>macroexpand</code>, <code>macroexpand-1</code> 함수를 사용하면 매크로 확장 결과를 확인할 수 있다.</p>
<pre><code class="language-lisp">(pprint (macroexpand `(while (able) (laugh))))
;;&gt;&gt; (BLOCK NIL
;;&gt;&gt;   (LET ()
;;&gt;&gt;     (DECLARE (IGNORABLE))
;;&gt;&gt;     (TAGBODY
;;&gt;&gt;       (GO #:G486)
;;&gt;&gt;      #:G485
;;&gt;&gt;       (TAGBODY (LAUGH))
;;&gt;&gt;       (PSETQ)
;;&gt;&gt;      #:G486
;;&gt;&gt;       (UNLESS (NOT (ABLE)) (GO #:G485))
;;&gt;&gt;       (RETURN-FROM NIL (PROGN)))))

(pprint (macroexpand-1 `(while (able) (laugh))))
;;&gt;&gt; (DO () ((NOT (ABLE))) (LAUGH))

(defmacro mac (expr)
  `(pprint (macroexpand-1 ',expr)))

(mac (while (able) (laugh)))
;;&gt;&gt; (DO () ((NOT (ABLE))) (LAUGH))
</code></pre>
<h2 id="75-인자-구조화된-할당"><a class="header" href="#75-인자-구조화된-할당">7.5. 인자 구조화된 할당</a></h2>
<p><code>destructuring-bind</code></p>
<pre><code class="language-lisp">(destructuring-bind (x (y) . z) '(a (b) c d)
  (list x y z))
;;=&gt; (A B (C D))
</code></pre>
<pre><code class="language-lisp">(defmacro our-dolist ((var list &amp;optional result) &amp;body body)
  `(progn
     (mapc #'(lambda (,var) ,@body)
           ,list)
     (let ((,var nil))
       ,result)))

(our-dolist (x '(a b c))
  (print x))
;;&gt;&gt; A
;;&gt;&gt; B
;;&gt;&gt; C
;;=&gt; NIL
</code></pre>
<pre><code class="language-lisp">(defmacro when-let ((var expr) &amp;body body) 
  `(let ((,var ,expr))
     (when ,var
       ,@body)))

(when-let (a 1)
  (1+ a))
;;=&gt; 2

(when-let (a nil)
  (1+ a))
;;=&gt; NIL
</code></pre>
<pre><code class="language-lisp">;; Figure 7.6: A sketch of defmacro.

(defmacro our-expander (name)
  `(get ,name 'expander))

(defmacro our-defmacro (name parms &amp;body body)
  (let ((g (gensym)))
    `(progn
       (setf (our-expander ',name)
             #'(lambda (,g)
                 (block ,name
                   (destructuring-bind ,parms (cdr ,g)
                     ,@body))))
       ',name)))

(defun our-macroexpand-1 (expr)
  (if (and (consp expr) (our-expander (car expr)))
      (funcall (our-expander (car expr)) expr)
      expr))

(our-defmacro hello (a)
  `(1+ ,a))

(our-macroexpand-1 '(hello 10))
;;=&gt; (1+ 10)
</code></pre>
<h2 id="76-매크로-모델"><a class="header" href="#76-매크로-모델">7.6. 매크로 모델</a></h2>
<p>패스</p>
<h2 id="77-프로그램으로서의-매크로"><a class="header" href="#77-프로그램으로서의-매크로">7.7. 프로그램으로서의 매크로</a></h2>
<p><code>setq</code>와 <code>psetq</code>(<code>p</code>arallel <code>setq</code>)의 차이</p>
<pre><code class="language-lisp"> (let ((a 1))
   (setq a 2 b a)
   (list a b))
;;=&gt; (2 2)

(let ((a 1))
  (psetq a 2 b a)
  (list a b))
;;=&gt; (2 1)
</code></pre>
<pre><code class="language-lisp">;; Figure 7.8: Implementing do.

(defmacro our-do (bindforms (test &amp;rest result) &amp;body body)
  (let ((label (gensym)))
    `(prog ,(make-initforms bindforms)
        ,label
        (if ,test
            (return (progn ,@result)))
        ,@body
        (psetq ,@(make-stepforms bindforms))
        (go ,label))))

(defun make-initforms (bindforms)
  (mapcar #'(lambda (b)
              (if (consp b)
                  (list (car b) (cadr b))
                  (list b nil)))
          bindforms))

(defun make-stepforms (bindforms)
  (mapcan #'(lambda (b)
              (if (and (consp b) (third b))
                  (list (car b) (third b))
                  nil))
          bindforms))

(do ((w 3)
     (x 1 (1+ x))
     (y 2 (1+ y))
     (z))
    ((&gt; x 10) (princ z) y)
  (princ x)
  (princ y))
;;&gt;&gt; 12233445566778899101011NIL
;;=&gt; 12

(our-do ((w 3)
         (x 1 (1+ x))
         (y 2 (1+ y))
         (z))
    ((&gt; x 10) (princ z) y)
  (princ x)
  (princ y))
;;&gt;&gt; 12233445566778899101011NIL
;;=&gt; 12
</code></pre>
<h2 id="78-매크로-스타일"><a class="header" href="#78-매크로-스타일">7.8. 매크로 스타일</a></h2>
<pre><code class="language-lisp">;; Figure 7.9: Two macros equivalent to and.

(defmacro our-and-1 (&amp;rest args)
  (case (length args)
    (0 t)
    (1 (car args))
    (t `(if ,(car args)
            (our-and-1 ,@(cdr args))))))

(defmacro our-and-2 (&amp;rest args)
  (if (null args)
      t
      (labels ((expander (rest)
                 (if (cdr rest)
                     `(if ,(car rest)
                          ,(expander (cdr rest)))
                     (car rest))))
        (expander args))))
</code></pre>
<p>매크로는 확장되기 전에 실재 구현이 숨겨져 있으므로, 성능에 영향을 주는 코드의 영향력을 파악하기 어렵다.</p>
<h2 id="79-매크로-의존성"><a class="header" href="#79-매크로-의존성">7.9. 매크로 의존성</a></h2>
<pre><code class="language-lisp">(defmacro mac (x)
 `(1+ ,x))

(setq fn (compile nil '(lambda (y) (mac y))))

(defmacro mac (x)
  `(+ ,x 100))

(funcall fn 1)
;;=&gt; 2
</code></pre>
<ol>
<li>어떠한 <code>A</code> 매크로를 정의한 후, <code>A</code>매크로를 호출하는 함수(또는 매크로)를 정의한다.</li>
<li>어떠한 <code>A</code> 매크로를 수정했다면, 직접 또는 다른 매크로를 통해 이를 호출하는 모든 함수(또는 매크로)도 다시 컴파일한다.</li>
</ol>
<h2 id="710-함수에서-매크로로"><a class="header" href="#710-함수에서-매크로로">7.10. 함수에서 매크로로</a></h2>
<pre><code class="language-lisp">(defun sum (&amp;rest args)
  (apply #'+ args))

(sum 1 2 3)
;;=&gt; 6


(defmacro sum-1 (&amp;rest args)
  `(apply #'+ (list ,@args)))

(macroexpand-1 '(sum-1 1 2 3))
;;=&gt; (APPLY #'+ (LIST 1 2 3))
;;=&gt; T


(defmacro sum-2 (&amp;rest args)
  `(+ ,@args))

(macroexpand-1 '(sum-2 1 2 3))
;;=&gt; (+ 1 2 3)
;;=&gt; T
</code></pre>
<pre><code class="language-lisp">(defun foo (x y z)
  (list x (let ((x y))
            (list x z))))

(foo 1 2 3)
;;=&gt; (1 (2 3))


(defmacro foo-macro (x y z)
  `(list ,x (let ((x ,y))
              (list x ,z))))

(foo-macro 1 2 3)
;;=&gt; (1 (2 3))
</code></pre>
<h2 id="711-심볼-매크로"><a class="header" href="#711-심볼-매크로">7.11. 심볼 매크로</a></h2>
<ul>
<li>CLTL2는 커먼 리스프에 새로운 종류의 매크로인 심볼 매크로(symbol-macro)를 도입했다.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>종류</th><th>정의</th><th>호출   출</th></tr></thead><tbody>
<tr><td>일반 매크로</td><td>defmacro</td><td>함수처럼 호출</td></tr>
<tr><td>심볼 매크로</td><td>symbol-macrolet</td><td>심볼처럼 호출</td></tr>
</tbody></table>
</div>
<pre><code class="language-lisp">(symbol-macrolet ((hi (progn (print "Howdy")
                             1)))
  (+ hi 2))
;;&gt;&gt; "Howdy"
;;=&gt; 3
</code></pre>
<p>18장에서 심볼 매크로를 사용하는 방법을 설명한다.</p>
<h2 id="짚고-넘어가기-6"><a class="header" href="#짚고-넘어가기-6">짚고 넘어가기</a></h2>
<ul>
<li>defmacro
<ul>
<li><code>'</code></li>
<li><code>`</code></li>
<li><code>,</code></li>
<li><code>,@</code></li>
</ul>
</li>
<li>macroexpand</li>
<li>macroexpand-1</li>
<li>symbol-macrolet</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="08-언제-매크로를-사용하는가"><a class="header" href="#08-언제-매크로를-사용하는가">08. 언제 매크로를 사용하는가</a></h1>
<h2 id="81-when-nothing-else-will-do"><a class="header" href="#81-when-nothing-else-will-do">8.1. When Nothing Else Will Do</a></h2>
<h2 id="82-매크로-혹은-함수"><a class="header" href="#82-매크로-혹은-함수">8.2. 매크로 혹은 함수?</a></h2>
<h2 id="83-applications-for-macros"><a class="header" href="#83-applications-for-macros">8.3. Applications for Macros</a></h2>
<h2 id="짚고-넘어가기-7"><a class="header" href="#짚고-넘어가기-7">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="09-변수-캡쳐variable-capture"><a class="header" href="#09-변수-캡쳐variable-capture">09. 변수 캡쳐(Variable Capture)</a></h1>
<h2 id="91-macro-argument-capture"><a class="header" href="#91-macro-argument-capture">9.1. Macro Argument Capture</a></h2>
<h2 id="92-free-symbol-capture"><a class="header" href="#92-free-symbol-capture">9.2. Free Symbol Capture</a></h2>
<h2 id="93-언제-캡쳐가-일어나는가"><a class="header" href="#93-언제-캡쳐가-일어나는가">9.3. 언제 캡쳐가 일어나는가</a></h2>
<h2 id="94-avoiding-capture-with-better-names"><a class="header" href="#94-avoiding-capture-with-better-names">9.4. Avoiding Capture with Better Names</a></h2>
<h2 id="95-avoiding-capture-by-prior-evaluation"><a class="header" href="#95-avoiding-capture-by-prior-evaluation">9.5. Avoiding Capture by Prior Evaluation</a></h2>
<h2 id="96-avoiding-capture-with-gensyms"><a class="header" href="#96-avoiding-capture-with-gensyms">9.6. Avoiding Capture with Gensyms</a></h2>
<h2 id="97-avoiding-capture-with-packages"><a class="header" href="#97-avoiding-capture-with-packages">9.7. Avoiding Capture with Packages</a></h2>
<h2 id="98-capture-in-other-name-spaces"><a class="header" href="#98-capture-in-other-name-spaces">9.8. Capture in Other Name-Spaces</a></h2>
<h2 id="99-why-bother"><a class="header" href="#99-why-bother">9.9. Why Bother?</a></h2>
<h2 id="짚고-넘어가기-8"><a class="header" href="#짚고-넘어가기-8">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-또-다른-매크로의-위험성"><a class="header" href="#10-또-다른-매크로의-위험성">10. 또 다른 매크로의 위험성</a></h1>
<h2 id="101-평가-횟수"><a class="header" href="#101-평가-횟수">10.1. 평가 횟수</a></h2>
<pre><code class="language-lisp">;;; Figure 10.1: Controlling argument evaluation.

;; 올바른 버전
(defmacro for-correct ((var start stop) &amp;body body)
  (let ((gstop (gensym)))
    `(do ((,var ,start (1+ ,var))
          (,gstop ,stop))
         ((&gt; ,var ,gstop))
       ,@body)))

;; 여러 번 평가:
(defmacro for-eval ((var start stop) &amp;body body)
  `(do ((,var ,start (1+ ,var)))             ; 올바른 버전에 비해, gensym을 사용하지 않았다.
       ((&gt; ,var ,stop))
     ,@body))

;; 옳지 않은 평가 순서:
(defmacro for-order ((var start stop) &amp;body body)
  (let ((gstop (gensym)))
    `(do ((,gstop ,stop)
          (,var ,start (1+ ,var)))          ; 올바른 버전에 비해, 1+ 가 아래에 있다
         ((&gt; ,var ,gstop))
       ,@body)))
</code></pre>
<h2 id="102-평가-순서"><a class="header" href="#102-평가-순서">10.2. 평가 순서</a></h2>
<pre><code class="language-lisp">(setq x 10)


(+ (setq x 3) x)
;;=&gt; 6
</code></pre>
<pre><code class="language-lisp">(let ((x 1))
  (for-order (i x (setq x 13))
    (princ i)))
;;&gt;&gt; 13
;;=&gt; NIL
</code></pre>
<pre><code class="language-lisp">(let ((x 1))
  (for-correct (i x (setq x 13))
    (princ i)))
;;&gt;&gt; 12345678910111213
;;=&gt; NIL
</code></pre>
<h2 id="103-함수형이-아닌-익스펜더"><a class="header" href="#103-함수형이-아닌-익스펜더">10.3. 함수형이 아닌 익스펜더</a></h2>
<h2 id="104-재귀"><a class="header" href="#104-재귀">10.4. 재귀</a></h2>
<h2 id="짚고-넘어가기-9"><a class="header" href="#짚고-넘어가기-9">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-classic-macros"><a class="header" href="#11-classic-macros">11. Classic Macros</a></h1>
<h2 id="111-creating-context"><a class="header" href="#111-creating-context">11.1. Creating Context</a></h2>
<h2 id="112-the-with--macro"><a class="header" href="#112-the-with--macro">11.2. The with- Macro</a></h2>
<h2 id="113-conditional-evaluation"><a class="header" href="#113-conditional-evaluation">11.3. Conditional Evaluation</a></h2>
<h2 id="114-iteration"><a class="header" href="#114-iteration">11.4. Iteration</a></h2>
<h2 id="115-iteration-with-multiple-values"><a class="header" href="#115-iteration-with-multiple-values">11.5. Iteration with Multiple Values</a></h2>
<h2 id="116-need-for-macros"><a class="header" href="#116-need-for-macros">11.6. Need for Macros</a></h2>
<h2 id="짚고-넘어가기-10"><a class="header" href="#짚고-넘어가기-10">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-generalized-variables"><a class="header" href="#12-generalized-variables">12. Generalized Variables</a></h1>
<h2 id="121-the-concept"><a class="header" href="#121-the-concept">12.1. The Concept</a></h2>
<h2 id="122-the-multiple-evaluation-problem"><a class="header" href="#122-the-multiple-evaluation-problem">12.2. The Multiple Evaluation Problem</a></h2>
<h2 id="123-new-utilities"><a class="header" href="#123-new-utilities">12.3. New Utilities</a></h2>
<h2 id="124-more-complex-utilities"><a class="header" href="#124-more-complex-utilities">12.4. More Complex Utilities</a></h2>
<h2 id="125-defining-inversions"><a class="header" href="#125-defining-inversions">12.5. Defining Inversions</a></h2>
<h2 id="짚고-넘어가기-11"><a class="header" href="#짚고-넘어가기-11">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-computation-at-compile-time"><a class="header" href="#13-computation-at-compile-time">13. Computation at Compile-Time</a></h1>
<h2 id="131-new-utilities"><a class="header" href="#131-new-utilities">13.1. New Utilities</a></h2>
<h2 id="132-example-bezier-curves"><a class="header" href="#132-example-bezier-curves">13.2. Example: Bezier Curves</a></h2>
<h2 id="133-applications"><a class="header" href="#133-applications">13.3. Applications</a></h2>
<h2 id="짚고-넘어가기-12"><a class="header" href="#짚고-넘어가기-12">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-anaphoric-macros"><a class="header" href="#14-anaphoric-macros">14. Anaphoric Macros</a></h1>
<h2 id="141-anaphoric-variants"><a class="header" href="#141-anaphoric-variants">14.1. Anaphoric Variants</a></h2>
<h2 id="142-failure"><a class="header" href="#142-failure">14.2. Failure</a></h2>
<h2 id="143-referential-transparency"><a class="header" href="#143-referential-transparency">14.3. Referential Transparency</a></h2>
<h2 id="짚고-넘어가기-13"><a class="header" href="#짚고-넘어가기-13">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-macros-returning-functions"><a class="header" href="#15-macros-returning-functions">15. Macros Returning Functions</a></h1>
<h2 id="151-building-functions"><a class="header" href="#151-building-functions">15.1. Building Functions</a></h2>
<h2 id="152-recursion-on-cdrs"><a class="header" href="#152-recursion-on-cdrs">15.2. Recursion on Cdrs</a></h2>
<h2 id="153-recursion-on-subtrees"><a class="header" href="#153-recursion-on-subtrees">15.3. Recursion on Subtrees</a></h2>
<h2 id="154-lazy-evaluation"><a class="header" href="#154-lazy-evaluation">15.4. Lazy Evaluation</a></h2>
<h2 id="짚고-넘어가기-14"><a class="header" href="#짚고-넘어가기-14">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="16-macro-defining-macros"><a class="header" href="#16-macro-defining-macros">16. Macro-Defining Macros</a></h1>
<h2 id="161-abbreviations"><a class="header" href="#161-abbreviations">16.1. Abbreviations</a></h2>
<h2 id="162-properties"><a class="header" href="#162-properties">16.2. Properties</a></h2>
<h2 id="163-anaphoric-macros"><a class="header" href="#163-anaphoric-macros">16.3. Anaphoric Macros</a></h2>
<h2 id="짚고-넘어가기-15"><a class="header" href="#짚고-넘어가기-15">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="17-read-macros"><a class="header" href="#17-read-macros">17. Read-Macros</a></h1>
<h2 id="171-macro-characters"><a class="header" href="#171-macro-characters">17.1. Macro Characters</a></h2>
<h2 id="172-dispatching-macro-characters"><a class="header" href="#172-dispatching-macro-characters">17.2. Dispatching Macro Characters</a></h2>
<h2 id="173-delimiters"><a class="header" href="#173-delimiters">17.3. Delimiters</a></h2>
<h2 id="174-when-what-happens"><a class="header" href="#174-when-what-happens">17.4. When What Happens</a></h2>
<h2 id="짚고-넘어가기-16"><a class="header" href="#짚고-넘어가기-16">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="18-destructuring"><a class="header" href="#18-destructuring">18. Destructuring</a></h1>
<h2 id="181-destructuring-on-lists"><a class="header" href="#181-destructuring-on-lists">18.1. Destructuring on Lists</a></h2>
<h2 id="182-other-structures"><a class="header" href="#182-other-structures">18.2. Other Structures</a></h2>
<h2 id="183-reference"><a class="header" href="#183-reference">18.3. Reference</a></h2>
<h2 id="184-matching"><a class="header" href="#184-matching">18.4. Matching</a></h2>
<h2 id="짚고-넘어가기-17"><a class="header" href="#짚고-넘어가기-17">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19-a-query-compiler"><a class="header" href="#19-a-query-compiler">19. A Query Compiler</a></h1>
<h2 id="191-the-database"><a class="header" href="#191-the-database">19.1. The Database</a></h2>
<h2 id="192-pattern-matching-queries"><a class="header" href="#192-pattern-matching-queries">19.2. Pattern-Matching Queries</a></h2>
<h2 id="193-a-query-interpreter"><a class="header" href="#193-a-query-interpreter">19.3. A Query Interpreter</a></h2>
<h2 id="194-restrictions-on-binding"><a class="header" href="#194-restrictions-on-binding">19.4. Restrictions on Binding</a></h2>
<h2 id="195-a-query-compiler"><a class="header" href="#195-a-query-compiler">19.5. A Query Compiler</a></h2>
<h2 id="짚고-넘어가기-18"><a class="header" href="#짚고-넘어가기-18">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="20-continuations"><a class="header" href="#20-continuations">20. Continuations</a></h1>
<h2 id="201-scheme-continuations"><a class="header" href="#201-scheme-continuations">20.1. Scheme Continuations</a></h2>
<h2 id="202-continuation-passing-macros"><a class="header" href="#202-continuation-passing-macros">20.2. Continuation-Passing Macros</a></h2>
<h2 id="203-code-walkers-and-cps-conversion"><a class="header" href="#203-code-walkers-and-cps-conversion">20.3. Code-Walkers and CPS Conversion</a></h2>
<h2 id="짚고-넘어가기-19"><a class="header" href="#짚고-넘어가기-19">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-multiple-processes"><a class="header" href="#21-multiple-processes">21. Multiple Processes</a></h1>
<h2 id="211-the-process-abstraction"><a class="header" href="#211-the-process-abstraction">21.1. The Process Abstraction</a></h2>
<h2 id="212-implementation"><a class="header" href="#212-implementation">21.2. Implementation</a></h2>
<h2 id="213-the-less-than-rapid-prototype"><a class="header" href="#213-the-less-than-rapid-prototype">21.3. The Less-than-Rapid Prototype</a></h2>
<h2 id="짚고-넘어가기-20"><a class="header" href="#짚고-넘어가기-20">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-nondeterminism"><a class="header" href="#22-nondeterminism">22. Nondeterminism</a></h1>
<h2 id="221-the-concepts"><a class="header" href="#221-the-concepts">22.1. The Concepts</a></h2>
<h2 id="222-search"><a class="header" href="#222-search">22.2. Search</a></h2>
<h2 id="223-scheme-implementation"><a class="header" href="#223-scheme-implementation">22.3. Scheme Implementation</a></h2>
<h2 id="224-common-lisp-implementation"><a class="header" href="#224-common-lisp-implementation">22.4. Common Lisp Implementation</a></h2>
<h2 id="225-cuts"><a class="header" href="#225-cuts">22.5. Cuts</a></h2>
<h2 id="226-true-nondeterminism"><a class="header" href="#226-true-nondeterminism">22.6. True Nondeterminism</a></h2>
<h2 id="짚고-넘어가기-21"><a class="header" href="#짚고-넘어가기-21">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="23-parsing-with-atns"><a class="header" href="#23-parsing-with-atns">23. Parsing with ATNs</a></h1>
<h2 id="231-background"><a class="header" href="#231-background">23.1. Background</a></h2>
<h2 id="232-the-formalism"><a class="header" href="#232-the-formalism">23.2. The Formalism</a></h2>
<h2 id="233-nondeterminism"><a class="header" href="#233-nondeterminism">23.3. Nondeterminism</a></h2>
<h2 id="234-an-atn-compiler"><a class="header" href="#234-an-atn-compiler">23.4. An ATN Compiler</a></h2>
<h2 id="235-a-sample-atn"><a class="header" href="#235-a-sample-atn">23.5. A Sample ATN</a></h2>
<h2 id="짚고-넘어가기-22"><a class="header" href="#짚고-넘어가기-22">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="24-prolog"><a class="header" href="#24-prolog">24. Prolog</a></h1>
<h2 id="241-concepts"><a class="header" href="#241-concepts">24.1. Concepts</a></h2>
<h2 id="242-an-interpreter"><a class="header" href="#242-an-interpreter">24.2. An Interpreter</a></h2>
<h2 id="243-rules"><a class="header" href="#243-rules">24.3. Rules</a></h2>
<h2 id="244-the-need-for-nondeterminism"><a class="header" href="#244-the-need-for-nondeterminism">24.4. The Need for Nondeterminism</a></h2>
<h2 id="245-new-implementation"><a class="header" href="#245-new-implementation">24.5. New Implementation</a></h2>
<h2 id="246-adding-prolog-features"><a class="header" href="#246-adding-prolog-features">24.6. Adding Prolog Features</a></h2>
<h2 id="247-examples"><a class="header" href="#247-examples">24.7. Examples</a></h2>
<h2 id="248-the-senses-of-compile"><a class="header" href="#248-the-senses-of-compile">24.8. The Senses of Compile</a></h2>
<h2 id="짚고-넘어가기-23"><a class="header" href="#짚고-넘어가기-23">짚고 넘어가기</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="25-object-oriented-lisp"><a class="header" href="#25-object-oriented-lisp">25. Object-Oriented Lisp</a></h1>
<h2 id="251-plus-ca-change"><a class="header" href="#251-plus-ca-change">25.1. Plus c¸a Change</a></h2>
<h2 id="252-objects-in-plain-lisp"><a class="header" href="#252-objects-in-plain-lisp">25.2. Objects in Plain Lisp</a></h2>
<h2 id="253-classes-and-instances"><a class="header" href="#253-classes-and-instances">25.3. Classes and Instances</a></h2>
<h2 id="254-methods"><a class="header" href="#254-methods">25.4. Methods</a></h2>
<h2 id="255-auxiliary-methods-and-combination"><a class="header" href="#255-auxiliary-methods-and-combination">25.5. Auxiliary Methods and Combination</a></h2>
<h2 id="256-clos-and-lisp"><a class="header" href="#256-clos-and-lisp">25.6. CLOS and Lisp</a></h2>
<h2 id="257-when-to-object"><a class="header" href="#257-when-to-object">25.7. When to Object</a></h2>
<h2 id="짚고-넘어가기-24"><a class="header" href="#짚고-넘어가기-24">짚고 넘어가기</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
